<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Path to AI Alignment — Curriculum Navigator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Instrument+Serif:ital@0;1&family=DM+Sans:wght@300;400;500;600;700&display=swap');

  :root {
    --bg: #0a0a0f;
    --bg-raised: #12121a;
    --bg-panel: #16161f;
    --bg-hover: #1e1e2a;
    --border: #2a2a3a;
    --border-bright: #3a3a5a;
    --text: #e0e0ec;
    --text-dim: #8888a0;
    --text-bright: #ffffff;
    --accent-1: #6ee7b7;
    --accent-2: #818cf8;
    --accent-3: #f9a8d4;
    --accent-4: #fbbf24;
    --accent-5: #38bdf8;
    --accent-6: #c084fc;
    --accent-7: #fb923c;
    --complete: #34d399;
    --in-progress: #fbbf24;
    --not-started: #4a4a6a;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    overflow: hidden;
    height: 100vh;
  }

  .app {
    display: grid;
    grid-template-columns: 280px 1fr 380px;
    grid-template-rows: auto 1fr;
    height: 100vh;
  }

  /* Header */
  .header {
    grid-column: 1 / -1;
    padding: 14px 24px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--bg-raised);
  }
  .header h1 {
    font-family: 'Instrument Serif', serif;
    font-size: 20px;
    font-weight: 400;
    color: var(--text-bright);
  }
  .header h1 span { color: var(--accent-1); }
  .header-stats {
    display: flex;
    gap: 20px;
    font-size: 12px;
    color: var(--text-dim);
  }
  .header-stats .stat-value {
    font-family: 'JetBrains Mono', monospace;
    color: var(--text);
    font-weight: 600;
  }
  .progress-bar-container {
    width: 180px;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }
  .progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-1), var(--accent-5));
    border-radius: 2px;
    transition: width 0.5s ease;
  }

  /* Sidebar */
  .sidebar {
    background: var(--bg-raised);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    padding: 12px 0;
  }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-track { background: transparent; }
  .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .nav-section-header {
    padding: 10px 16px 6px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 1.5px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    user-select: none;
  }
  .nav-section-header:hover { background: var(--bg-hover); }
  .nav-section-header .chevron {
    transition: transform 0.2s;
    font-size: 8px;
  }
  .nav-section-header .chevron.collapsed { transform: rotate(-90deg); }

  .nav-item {
    padding: 6px 16px 6px 24px;
    font-size: 13px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-dim);
    transition: all 0.15s;
  }
  .nav-item:hover { background: var(--bg-hover); color: var(--text); }
  .nav-item.active { background: var(--bg-hover); color: var(--text-bright); }

  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
    cursor: pointer;
    transition: transform 0.15s;
  }
  .status-dot:hover { transform: scale(1.4); }

  .nav-item-checkpoint {
    padding: 5px 16px 5px 32px;
    font-size: 11px;
    color: var(--text-dim);
    cursor: pointer;
    font-style: italic;
    opacity: 0.7;
  }
  .nav-item-checkpoint:hover { opacity: 1; background: var(--bg-hover); }

  /* Main Canvas */
  .main-canvas {
    position: relative;
    overflow: hidden;
    background: var(--bg);
  }
  .canvas-controls {
    position: absolute;
    top: 12px;
    left: 12px;
    z-index: 10;
    display: flex;
    gap: 4px;
    background: var(--bg-raised);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 3px;
  }
  .canvas-btn {
    padding: 5px 12px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    background: transparent;
    color: var(--text-dim);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .canvas-btn:hover { color: var(--text); background: var(--bg-hover); }
  .canvas-btn.active { color: var(--text-bright); background: var(--bg-hover); }
  .sync-btn {
    background: none; border: 1px solid var(--border); color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace; font-size: 11px;
    padding: 4px 12px; border-radius: 6px; cursor: pointer; white-space: nowrap;
    transition: all 0.2s;
  }
  .sync-btn:hover { color: var(--complete); border-color: var(--complete); }
  .sync-btn.syncing { opacity: 0.5; pointer-events: none; }
  .sync-btn.success { color: var(--complete); border-color: var(--complete); }
  .sync-btn.error { color: #f87171; border-color: #f87171; }

  .canvas-legend {
    position: absolute;
    bottom: 12px;
    left: 12px;
    display: flex;
    gap: 14px;
    font-size: 11px;
    color: var(--text-dim);
    z-index: 10;
  }
  .legend-item { display: flex; align-items: center; gap: 5px; }
  .legend-dot { width: 8px; height: 8px; border-radius: 50%; }

  svg.graph { width: 100%; height: 100%; }

  .edge {
    stroke: var(--border);
    stroke-width: 1.2;
    opacity: 0.4;
    transition: all 0.3s;
  }
  .edge.highlighted { stroke: var(--accent-5); opacity: 0.9; stroke-width: 2; }
  .edge-cross-phase {
    stroke-dasharray: 6 4;
    opacity: 0.2;
  }
  .edge-cross-phase.highlighted { opacity: 0.6; stroke: var(--accent-6); }

  .node-group { cursor: pointer; }
  .node-circle {
    stroke-width: 2;
    transition: all 0.2s;
  }
  .node-group:hover .node-circle { stroke-width: 3; filter: brightness(1.3); }
  .node-number {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    font-weight: 600;
    text-anchor: middle;
    pointer-events: none;
  }

  /* Detail Panel */
  .detail-panel {
    background: var(--bg-panel);
    border-left: 1px solid var(--border);
    overflow-y: auto;
    padding: 20px;
  }
  .detail-panel::-webkit-scrollbar { width: 4px; }
  .detail-panel::-webkit-scrollbar-track { background: transparent; }
  .detail-panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .detail-empty {
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: var(--text-dim);
    font-size: 13px;
    padding: 20px;
  }
  .empty-icon { font-size: 32px; margin-bottom: 12px; opacity: 0.3; }

  .detail-header { margin-bottom: 16px; }
  .detail-phase-tag {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 1px;
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 6px;
  }
  .detail-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-bright);
    line-height: 1.3;
    margin-bottom: 8px;
  }
  .detail-meta {
    display: flex;
    gap: 16px;
    font-size: 12px;
    color: var(--text-dim);
  }
  .detail-section {
    margin-bottom: 16px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
  }
  .detail-section-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-dim);
    letter-spacing: 0.5px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .detail-section-title .icon { font-size: 13px; }

  .prereq-list, .concept-check-list, .failure-list, .project-list {
    list-style: none;
    padding: 0;
  }
  .prereq-list li, .concept-check-list li, .failure-list li {
    font-size: 12px;
    padding: 4px 0;
    line-height: 1.5;
    color: var(--text);
  }
  .concept-check-list li::before { content: "□ "; color: var(--accent-5); font-weight: bold; }
  .failure-list li::before { content: "⚠ "; }

  .prereq-link {
    color: var(--accent-5);
    cursor: pointer;
    font-weight: 500;
    border-bottom: 1px dashed var(--accent-5);
  }
  .prereq-link:hover { color: var(--text-bright); }

  .mvl-resource {
    font-size: 12px;
    padding: 6px 0;
    line-height: 1.5;
  }
  .res-type {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    font-weight: 700;
    color: var(--accent-4);
    display: inline;
    margin-right: 6px;
  }

  .project-item {
    font-size: 12px;
    padding: 4px 0;
    display: flex;
    align-items: flex-start;
    gap: 6px;
  }
  .project-badge {
    font-family: 'JetBrains Mono', monospace;
    font-size: 8px;
    font-weight: 700;
    padding: 1px 5px;
    border-radius: 3px;
    flex-shrink: 0;
    margin-top: 2px;
  }
  .project-badge.new { background: rgba(56,189,248,0.15); color: var(--accent-5); }
  .project-badge.extends { background: rgba(192,132,252,0.15); color: var(--accent-6); }

  .mobile-close-btn {
    display: none;
    position: sticky;
    top: 0;
    z-index: 10;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'DM Sans', sans-serif;
    font-size: 13px;
    margin-bottom: 12px;
    width: 100%;
  }
  .mobile-close-btn:hover { color: var(--text); background: var(--bg-hover); }

  .detail-backdrop {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 99;
  }
  .detail-backdrop.open { display: block; }

  /* Responsive */
  @media (max-width: 1100px) {
    .app { grid-template-columns: 240px 1fr 320px; }
  }

  @media (max-width: 900px) {
    .app {
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
    }
    .sidebar { display: none; }
    .header h1 { font-size: 15px; }
    .header-stats { gap: 8px; font-size: 10px; }
    .header { padding: 8px 12px; flex-wrap: wrap; gap: 4px; }
    .progress-bar-container { width: 120px; }
    .main-canvas { overflow: hidden; position: relative; }
    /* Hide SVG on mobile — we use HTML views instead */
    svg.graph { display: none; }
    .canvas-legend { display: none !important; }
    .canvas-controls {
      position: relative;
      top: 0; left: 0;
      margin: 8px;
      width: calc(100% - 16px);
      justify-content: center;
      z-index: 10;
    }
    .canvas-controls .canvas-btn { padding: 8px 14px; font-size: 11px; flex: 1; text-align: center; }

    .detail-panel {
      display: none;
      position: fixed;
      bottom: 0; left: 0; right: 0;
      max-height: 60vh;
      z-index: 100;
      border-left: none;
      border-top: 2px solid var(--accent-5);
      border-radius: 12px 12px 0 0;
      padding: 12px 16px;
      animation: slideUp 0.25s ease;
      overflow-y: auto;
    }
    .detail-panel.mobile-open { display: block; }
    .mobile-close-btn { display: flex; align-items: center; justify-content: center; }
    .detail-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 99;
    }
    .detail-backdrop.visible { display: block; }
  }

  /* Mobile HTML view containers (dependency + timeline) */
  .mobile-view {
    display: none;
    position: absolute;
    inset: 0;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    background: var(--bg);
    padding: 60px 14px 20px;
  }
  .mobile-view.active { display: block; }

  /* Legacy alias */
  .mobile-timeline {
    display: none;
    position: absolute;
    inset: 0;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    background: var(--bg);
    padding: 60px 14px 20px;
  }
  .mt-header {
    text-align: center;
    margin-bottom: 20px;
  }
  .mt-header h2 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 20px;
    font-weight: 700;
    color: var(--text-bright);
    margin-bottom: 4px;
  }
  .mt-header .mt-subtitle {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--accent-1);
    margin-bottom: 2px;
  }
  .mt-header .mt-meta {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
  }
  .mt-phase {
    margin-bottom: 16px;
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }
  .mt-phase-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    background: var(--bg-raised);
  }
  .mt-phase-name {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    font-weight: 600;
  }
  .mt-phase-stats {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
  }
  .mt-phase-bar {
    height: 4px;
    background: var(--border);
  }
  .mt-phase-bar-fill {
    height: 100%;
    border-radius: 0 2px 2px 0;
    transition: width 0.3s ease;
  }
  .mt-phase-lessons {
    padding: 6px 12px;
  }
  .mt-lesson {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 5px 0;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    border-bottom: 1px solid var(--border);
    cursor: pointer;
  }
  .mt-lesson:last-child { border-bottom: none; }
  .mt-lesson-num {
    width: 24px;
    text-align: center;
    font-weight: 600;
    font-size: 10px;
    flex-shrink: 0;
  }
  .mt-lesson-title {
    flex: 1;
    color: var(--text);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .mt-lesson-hours {
    font-size: 9px;
    color: var(--text-dim);
    flex-shrink: 0;
  }
  .mt-lesson-status {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  /* Mobile Dependency View */
  .md-phase {
    margin-bottom: 12px;
  }
  .md-phase-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    background: var(--bg-raised);
    border: 1px solid var(--border);
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  }
  .md-phase-header.collapsed { border-radius: 8px; }
  .md-phase-name {
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    font-weight: 700;
  }
  .md-phase-right {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .md-phase-progress {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
  }
  .md-phase-chevron {
    font-size: 12px;
    color: var(--text-dim);
    transition: transform 0.2s;
  }
  .md-phase-header.collapsed .md-phase-chevron { transform: rotate(-90deg); }
  .md-phase-body {
    border: 1px solid var(--border);
    border-top: none;
    border-radius: 0 0 8px 8px;
    overflow: hidden;
  }
  .md-phase-body.collapsed { display: none; }
  .md-lesson-card {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
    cursor: pointer;
    transition: background 0.15s;
  }
  .md-lesson-card:last-child { border-bottom: none; }
  .md-lesson-card:active { background: var(--bg-hover); }
  .md-status-btn {
    width: 22px;
    height: 22px;
    border-radius: 50%;
    border: 2px solid;
    background: transparent;
    cursor: pointer;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 10px;
    transition: all 0.15s;
    padding: 0;
  }
  .md-status-btn:active { transform: scale(0.9); }
  .md-lesson-info {
    flex: 1;
    min-width: 0;
  }
  .md-lesson-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 700;
    margin-right: 6px;
  }
  .md-lesson-name {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    color: var(--text);
    display: block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .md-lesson-meta {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 3px;
  }
  .md-lesson-hours {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: var(--text-dim);
  }
  .md-lesson-prereqs {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: var(--text-dim);
    opacity: 0.7;
  }
  .md-prereq-met { color: var(--complete); opacity: 1; }
  .md-lesson-chevron {
    color: var(--text-dim);
    font-size: 12px;
    flex-shrink: 0;
    opacity: 0.4;
  }

  @keyframes slideUp {
    from { transform: translateY(100%); }
    to { transform: translateY(0); }
  }

  /* Calendar styles */
  .cal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px 12px;
  }
  .cal-nav {
    background: none;
    border: 1px solid var(--border);
    color: var(--text-dim);
    width: 28px;
    height: 28px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
  }
  .cal-nav:hover { color: var(--text); border-color: var(--border-bright); background: var(--bg-hover); }
  .cal-month-label {
    font-family: 'Instrument Serif', serif;
    font-size: 20px;
    color: var(--text-bright);
  }
  .cal-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 1px;
    padding: 0 20px 20px;
    flex: 1;
    min-height: 0;
  }
  .cal-dow {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    color: var(--text-dim);
    text-align: center;
    padding: 4px 0 8px;
    letter-spacing: 1px;
  }
  .cal-day {
    background: var(--bg-raised);
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 4px;
    min-height: 72px;
    cursor: pointer;
    transition: all 0.15s;
    position: relative;
    overflow: hidden;
  }
  .cal-day:hover { border-color: var(--border-bright); background: var(--bg-hover); }
  .cal-day.empty { background: transparent; cursor: default; border: none; }
  .cal-day.empty:hover { background: transparent; }
  .cal-day.today { border-color: var(--accent-5); box-shadow: 0 0 0 1px rgba(56,189,248,0.2); }
  .cal-day.selected { border-color: var(--accent-5); background: rgba(56,189,248,0.06); }
  .cal-day-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-dim);
    margin-bottom: 3px;
  }
  .cal-day.today .cal-day-num { color: var(--accent-5); }
  .cal-chip {
    display: flex;
    align-items: center;
    gap: 3px;
    padding: 2px 5px;
    margin-bottom: 2px;
    border-radius: 3px;
    font-size: 10px;
    font-family: 'JetBrains Mono', monospace;
    cursor: pointer;
    transition: filter 0.15s;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
  .cal-chip:hover { filter: brightness(1.3); }
  .cal-chip-num {
    font-weight: 700;
    flex-shrink: 0;
  }
  .cal-chip-title {
    font-family: 'DM Sans', sans-serif;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .cal-unscheduled {
    padding: 12px 20px;
    border-top: 1px solid var(--border);
  }
  .cal-unscheduled-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    color: var(--text-dim);
    letter-spacing: 1px;
    margin-bottom: 8px;
  }
  .cal-pool-chip {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 3px 8px;
    margin: 2px 3px;
    border-radius: 4px;
    font-size: 11px;
    cursor: grab;
    transition: all 0.15s;
    border: 1px solid transparent;
    user-select: none;
  }
  .cal-pool-chip:hover { border-color: var(--border-bright); filter: brightness(1.2); }
  .cal-pool-chip.dragging { opacity: 0.5; }
  .cal-day.drag-over { border-color: var(--accent-5) !important; background: rgba(56,189,248,0.1) !important; }

  /* Picker in detail panel */
  .picker-lesson {
    padding: 6px 8px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    border-radius: 4px;
    transition: background 0.15s;
  }
  .picker-lesson:hover { background: var(--bg-hover); }
  .picker-lesson-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 700;
    width: 24px;
    text-align: center;
    flex-shrink: 0;
  }
  .picker-hours {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
    margin-left: auto;
  }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <h1>The Path to <span>AI Alignment</span></h1>
    <div class="header-stats">
      <div>
        <span class="stat-value" id="stat-complete">0</span>/<span class="stat-value" id="stat-total">0</span> lessons
        <div class="progress-bar-container">
          <div class="progress-bar-fill" id="progress-fill" style="width:0%"></div>
        </div>
      </div>
      <div>
        ~<span class="stat-value" id="stat-hours-done">0</span><span style="color:#6ee7b7">h done</span> · ~<span class="stat-value" id="stat-hours-left">0</span><span style="color:#fbbf24">h remaining</span>
      </div>
      <button class="sync-btn" id="sync-btn" onclick="syncReadmeToGithub()" title="Update README.md on GitHub with current progress">
        <span id="sync-icon">⬆</span> Sync README
      </button>
    </div>
  </div>

  <div class="sidebar" id="sidebar"></div>

  <div class="main-canvas" id="main-canvas">
    <div class="canvas-controls">
      <button class="canvas-btn active" onclick="setView('dependency')">Dependency Map</button>
      <button class="canvas-btn" onclick="setView('timeline')">Timeline</button>
      <button class="canvas-btn" onclick="setView('calendar')">Calendar</button>
    </div>
    <div class="canvas-legend" id="canvas-legend">
      <div class="legend-item"><div class="legend-dot" style="background:var(--complete)"></div> Complete</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--in-progress)"></div> In Progress</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--not-started)"></div> Not Started</div>
      <div class="legend-item" style="color:var(--text-dim)">— prerequisite</div>
      <div class="legend-item" style="color:var(--text-dim)">┄ cross-phase</div>
    </div>
    <svg class="graph" id="graph-svg"></svg>
    <div class="mobile-view" id="mobile-dependency" style="display:none"></div>
    <div class="mobile-view" id="mobile-timeline" style="display:none"></div>
    <div id="calendar-view" style="display:none;position:absolute;inset:0;overflow-y:auto;background:var(--bg)"></div>
  </div>

  <div class="detail-backdrop" id="detail-backdrop" onclick="closeMobileDetail()"></div>

  <div class="detail-panel" id="detail-panel">
    <button class="mobile-close-btn" onclick="closeMobileDetail()">✕ Close</button>
    <div class="detail-empty" id="detail-empty">
      <div class="empty-icon">◇</div>
      <p>Click any lesson node to view details, concept checks, failure modes, and prerequisites.</p>
    </div>
    <div id="detail-content" style="display:none"></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════
// DATA
// ═══════════════════════════════════════════════

const PHASES = [
  { id: 'p0', name: 'Setup', color: '#94a3b8', hours: '2–4h' },
  { id: 'p1', name: 'Linear Algebra', color: '#6ee7b7', hours: '22–30h' },
  { id: 'p2', name: 'Calculus for ML', color: '#818cf8', hours: '20–28h' },
  { id: 'p3', name: 'Probability & Info Theory', color: '#f9a8d4', hours: '22–30h' },
  { id: 'p4', name: 'Applied Statistics', color: '#f472b6', hours: '18–26h' },
  { id: 'p5', name: 'Math Enrichment', color: '#e879f9', hours: '34–48h' },
  { id: 'p6', name: 'Neural Networks', color: '#fbbf24', hours: '42–58h' },
  { id: 'p7', name: 'Interpretability', color: '#38bdf8', hours: '26–38h' },
  { id: 'p8', name: 'Alignment Theory', color: '#c084fc', hours: '25–35h' },
  { id: 'p9', name: 'Research', color: '#fb923c', hours: '∞' },
];

const LESSONS = [
  // ─── Phase 0: Setup ───
  {
    id: 0, phase: 'p0', title: 'Python and NumPy for Machine Learning',
    status: 'not-started', hours: '2–4h',
    prereqs: [],
    crossPhaseLinks: [],
    conceptChecks: [
      'Can you create a matrix in NumPy and multiply it by a vector with @?',
      'Can you plot vectors as arrows with matplotlib?',
      'Do you understand NumPy broadcasting?',
    ],
    failureModes: [
      'Writing Python for-loops when NumPy vectorized operations exist — always think "whole array at once"',
      'Spending too long here if you already know NumPy — skim and move on',
    ],
    mvl: [
      { type: 'Do', text: 'Multiply two 1000×1000 matrices: for-loops vs A @ B. Feel the 100x speedup.' },
      { type: 'Do', text: 'Plot the unit circle, apply a 2×2 matrix, see the ellipse' },
    ],
    projects: [],
  },
  {
    id: 1, phase: 'p0', title: 'PyTorch — The Language of Alignment Research',
    status: 'not-started', hours: '4–6h',
    prereqs: [0],
    crossPhaseLinks: [],
    conceptChecks: [
      'Can you create a tensor with requires_grad=True and compute gradients via backward()?',
      'Do you understand the training loop pattern: zero_grad → forward → loss → backward → step?',
      'Can you register a forward hook on a module and inspect activations?',
      'Can you use torch.einsum for matrix multiplication and attention scores?',
    ],
    failureModes: [
      'Forgetting torch.no_grad() during inference — causes memory leaks from graph accumulation',
      'Mixing devices (CPU tensor + GPU tensor) — all operations must be on the same device',
      'Using NumPy operations on data that needs gradients — breaks the computation graph',
    ],
    mvl: [
      { type: 'Read', text: 'PyTorch 60-Minute Blitz tutorial' },
      { type: 'Do', text: 'Port a Phase 1 NumPy exercise to PyTorch, verify identical results' },
      { type: 'Do', text: 'Build a minimal training loop: 2-layer MLP on toy data' },
      { type: 'Do', text: 'ARENA Chapter 0.0 einops/einsum exercises' },
    ],
    projects: [
      { text: 'Autograd experiment: manual gradient verification' },
      { text: 'Hook exercise: intercept intermediate activations in a pretrained model' },
    ],
  },
  // ─── Phase 1: Linear Algebra ───
  {
    id: 2, phase: 'p1', title: 'Vectors — What They Actually Are',
    status: 'complete', hours: '2–3h',
    prereqs: [],
    crossPhaseLinks: [],
    conceptChecks: [
      'What\'s the difference between a vector as an arrow vs. a list of numbers?',
      'If you change the basis, do the coordinates change? Does the arrow change?',
      'What does it mean geometrically to multiply a vector by -2?',
    ],
    failureModes: [
      'Thinking coordinates ARE the vector rather than a description relative to a basis',
      'Confusing scalar multiplication with matrix-vector multiplication',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B Ch. 1 — "Vectors, what even are they?"' },
      { type: 'Do', text: 'Plot v, 2v, -v, and v + [2,2] in matplotlib' },
    ],
    projects: [
      { text: 'Vector plotting toolkit (matplotlib)' },
    ],
  },
  {
    id: 3, phase: 'p1', title: 'Linear Combinations, Span, and Basis',
    status: 'complete', hours: '3–4h',
    prereqs: [2],
    crossPhaseLinks: [],
    conceptChecks: [
      'If two vectors are parallel, what is their span?',
      'How many vectors do you need to span ℝ³?',
      'Can 3 vectors in ℝ² be linearly independent? Why not?',
      'What does it mean for a set of vectors to be a basis?',
    ],
    failureModes: [
      'Confusing "span" (the set of all reachable vectors) with "spanning set" (the vectors doing the spanning)',
      'Thinking you always need exactly n vectors for ℝⁿ — you need n linearly independent vectors',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B Ch. 2 — "Linear combinations, span, and basis vectors"' },
      { type: 'Do', text: 'Show any 2D point as a linear combination of 2 random non-parallel vectors' },
    ],
    projects: [
      { text: 'Add span visualization to vector toolkit' },
    ],
  },
  {
    id: 4, phase: 'p1', title: 'Linear Transformations and Matrices',
    status: 'complete', hours: '3–5h',
    prereqs: [3],
    crossPhaseLinks: [],
    conceptChecks: [
      'What does "the columns of a matrix are where the basis vectors land" mean?',
      'If a matrix\'s columns are parallel, what happens to 2D space?',
      'Why do lines stay lines under a linear transformation?',
      'Given a specific matrix, can you visualize what it does before computing anything?',
    ],
    failureModes: [
      'Thinking of a matrix as "just a grid of numbers" rather than a transformation',
      'Forgetting that matrix-vector multiplication IS applying a transformation',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B Ch. 3 — "Linear transformations and matrices" (THE key video)' },
      { type: 'Do', text: 'Plot a grid before and after transformation by various 2×2 matrices' },
    ],
    projects: [
      { text: 'Add transformation visualization (grid before/after)' },
    ],
  },
  {
    id: 5, phase: 'p1', title: 'Matrix Operations Deep Dive',
    status: 'complete', hours: '3–4h',
    prereqs: [4],
    crossPhaseLinks: [],
    conceptChecks: [
      'Explain both the row-dot-product and column-linear-combination views of Ax',
      'Why is AB ≠ BA in general? Give a geometric reason.',
      'What does (AB)ᵀ = BᵀAᵀ mean about the order of composed operations?',
    ],
    failureModes: [
      'Only knowing one view of matrix multiplication — you need BOTH (row and column) to read interp papers',
      'Assuming matrix multiplication is commutative like scalar multiplication',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B Ch. 3–4 (re-watch with both multiplication views in mind)' },
      { type: 'Do', text: 'Implement matrix multiply two ways: row-dot and column-combination' },
    ],
    projects: [
      { text: 'Matrix multiplication from scratch (Python, no NumPy)' },
    ],
  },
  {
    id: 6, phase: 'p1', title: 'Rank, Null Space, and Column Space',
    status: 'complete', hours: '4–5h',
    prereqs: [4, 5],
    crossPhaseLinks: [],
    conceptChecks: [
      'If a 3×3 matrix has rank 2, what dimension does it map 3D space onto?',
      'State the rank-nullity theorem and explain what it means about information.',
      'If Ax = 0 has only the trivial solution, what is the rank?',
    ],
    failureModes: [
      'Confusing column space (set of outputs) with null space (inputs that map to zero)',
      'Forgetting that rank-deficient means information is lost PERMANENTLY',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B Ch. 7 — "Inverse matrices, column space, null space"' },
      { type: 'Do', text: 'Create a rank-2 matrix in ℝ³, visualize the squished plane' },
    ],
    projects: [
      { text: 'Add rank/nullspace visualization to transformation toolkit' },
    ],
  },
  {
    id: 7, phase: 'p1', title: 'The Determinant',
    status: 'complete', hours: '2–3h',
    prereqs: [4, 6],
    crossPhaseLinks: [],
    conceptChecks: [
      'What does det(A) = 0 tell you geometrically? Algebraically? About invertibility?',
      'If det(A) = -3, what happened to area AND orientation?',
      'Why does det(AB) = det(A)·det(B) make geometric sense?',
    ],
    failureModes: [
      'Memorizing the formula without understanding it as area/volume scaling',
      'Forgetting that det=0, rank-deficient, non-invertible, and non-trivial null space are ALL the same thing',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B Ch. 6 — "The determinant"' },
      { type: 'Do', text: 'Visualize unit square deformation and measure area vs determinant' },
    ],
    projects: [],
  },
  {
    id: 8, phase: 'p1', title: 'Eigenvalues and Eigenvectors',
    status: 'complete', hours: '4–6h',
    prereqs: [6, 7],
    crossPhaseLinks: [],
    conceptChecks: [
      'What is special about an eigenvector geometrically?',
      'If λ = 0, what does that tell you about the matrix?',
      'What does A = PDP⁻¹ mean in words? (Three steps)',
      'Why does diagonalization make computing Aⁿ trivial?',
    ],
    failureModes: [
      'Confusing eigenvectors (directions that only scale) with singular vectors (SVD directions) — they are NOT the same for non-symmetric matrices',
      'Thinking all matrices can be diagonalized — some can\'t (defective matrices)',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B Ch. 14 — "Eigenvectors and eigenvalues"' },
      { type: 'Do', text: 'Find eigenvalues/vectors of 2×2 matrices, visualize invariant directions' },
    ],
    projects: [
      { text: 'Add eigenvector visualization to transformation toolkit' },
    ],
  },
  {
    id: 9, phase: 'p1', title: 'Singular Value Decomposition (SVD)',
    status: 'in-progress', hours: '5–7h',
    prereqs: [8],
    crossPhaseLinks: [],
    conceptChecks: [
      'What does A = UΣVᵀ mean as three geometric steps?',
      'How is SVD different from eigendecomposition? When do they coincide?',
      'What does keeping only the top-k singular values do geometrically?',
      'How is rank related to singular values?',
    ],
    failureModes: [
      'Confusing U and V — V rotates the INPUT space, U rotates the OUTPUT space',
      'Thinking SVD and eigendecomposition are the same thing (they agree only for symmetric matrices)',
      'Forgetting singular values are always non-negative (unlike eigenvalues)',
    ],
    mvl: [
      { type: 'Watch', text: 'Steve Brunton — "SVD: Overview" + "Matrix Approximation"' },
      { type: 'Do', text: 'Image compression: reconstruct image with k=1,5,10,50 singular values' },
    ],
    projects: [
      { text: 'Image compression via SVD project' },
    ],
  },
  {
    id: 10, phase: 'p1', title: 'Dot Products, Orthogonality, and Projections',
    status: 'not-started', hours: '4–6h',
    prereqs: [5, 9],
    crossPhaseLinks: [37],
    conceptChecks: [
      'Give both the algebraic AND geometric formulas for the dot product. Why are they equal?',
      'What does a·b = 0 mean geometrically?',
      'What is the projection of u onto v, and why is the residual perpendicular to v?',
      'Why is cosine similarity better than raw dot product for comparing word embeddings?',
    ],
    failureModes: [
      'Confusing "orthogonal" (perpendicular, dot product = 0) with "orthonormal" (orthogonal AND unit length)',
      'Thinking the projection formula proj_v(u) = (u·v/v·v)v gives a scalar — it gives a VECTOR',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B Ch. 9 — "Dot products and duality"' },
      { type: 'Do', text: 'Cosine similarity on GloVe/Word2Vec word pairs' },
    ],
    projects: [
      { text: 'Word embedding similarity explorer' },
    ],
  },
  {
    id: 11, phase: 'p1', title: 'Change of Basis, Norms, and Special Matrices',
    status: 'not-started', hours: '4–5h',
    prereqs: [8, 9, 10],
    crossPhaseLinks: [],
    conceptChecks: [
      'What does B⁻¹AB represent? Why is it the "same" transformation?',
      'Why does eigendecomposition A = PDP⁻¹ equal "view in eigenbasis, scale, view back"?',
      'Draw the unit balls for L1, L2, and L∞ norms. Why does L1 encourage sparsity?',
      'What does "positive definite" mean geometrically (think bowl shape)?',
    ],
    failureModes: [
      'Mixing up the direction of basis change: B⁻¹v converts TO the new basis, not from it',
      'Confusing norms: L1 (diamond), L2 (circle), L∞ (square) — draw them!',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B Ch. 13 — "Change of basis"' },
      { type: 'Do', text: 'Diagonalize A = PDP⁻¹ and verify; plot all three norm balls in 2D' },
    ],
    projects: [],
  },
  {
    id: 12, phase: 'p1', title: 'Linear Algebra Capstone',
    status: 'not-started', hours: '4–6h',
    prereqs: [10, 11],
    crossPhaseLinks: [],
    conceptChecks: [
      'For a given 3×3 matrix, explain rank, determinant, eigenvalues, SVD, and condition number geometrically.',
      'How does the neuron basis vs feature basis distinction relate to change of basis?',
      'Trace the path: vectors → transformations → rank → eigenvalues → SVD. How does each build on the last?',
    ],
    failureModes: [
      'Treating concepts as isolated — the capstone is about seeing them as ONE story',
      'Skipping the 3B1B full playlist re-watch. It hits differently after studying each piece.',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B full Essence of Linear Algebra playlist (re-watch)' },
      { type: 'Do', text: '30-minute comprehensive test + capstone visualization (SVD decomposition step by step)' },
    ],
    projects: [
      { text: 'Final capstone: SVD step-by-step visualization on unit circle' },
    ],
  },
  {
    id: 'p2-0', phase: 'p2', title: 'Calculus Fundamentals — Rebuilding Intuition',
    status: 'not-started', hours: '6–10h',
    prereqs: [12],
    crossPhaseLinks: [],
    conceptChecks: [
      'Can you differentiate any polynomial, exponential, or trig function confidently?',
      'Can you apply the chain rule to 2–3 nested functions?',
      'Can you derive σ\'(x) = σ(x)(1 - σ(x)) from scratch?',
      'Can you explain geometrically why "zooming in" makes gradient descent work?',
    ],
    failureModes: [
      'Rushing through drill problems — speed and confidence with basic rules is critical before matrix calculus',
      'Skipping the 3B1B Essence of Calculus playlist — it rebuilds intuition that textbooks alone cannot',
      'Memorizing rules without geometric understanding — always know what the derivative MEANS',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — Essence of Calculus full playlist (12 videos)' },
      { type: 'Do', text: 'All four drill sets + sigmoid derivative derivation' },
      { type: 'Do', text: 'Learning rate visualization: gradient descent on x⁴ - 2x² + 1' },
    ],
    projects: [],
  },
  // ─── Phase 2: Calculus ───
  {
    id: 13, phase: 'p2', title: 'Matrix Calculus — Bridging to Backprop',
    status: 'not-started', hours: '3–5h',
    prereqs: [5, 'p2-0'],
    crossPhaseLinks: [12],
    conceptChecks: [
      'What is a partial derivative geometrically?',
      'What is the gradient vector and which direction does it point?',
      'What is the Jacobian and when do you need it (vs just a gradient)?',
    ],
    failureModes: [
      'Confusing the gradient (a vector) with the Jacobian (a matrix)',
      'Forgetting that the gradient points UPHILL — gradient DESCENT goes in the negative gradient direction',
    ],
    mvl: [
      { type: 'Read', text: '"The Matrix Calculus You Need for Deep Learning" by Parr & Howard' },
      { type: 'Do', text: 'Compute gradient of f(x,y) = x²y + sin(xy) by hand; verify numerically' },
    ],
    projects: [],
  },
  {
    id: 14, phase: 'p2', title: 'Partial Derivatives and Gradients — Going Deeper',
    status: 'not-started', hours: '3–4h',
    prereqs: [13],
    crossPhaseLinks: [],
    conceptChecks: [
      'Why is the gradient perpendicular to contour lines?',
      'What is a directional derivative and how does it relate to the gradient?',
      'If you walk in the gradient direction, are you going uphill or downhill?',
    ],
    failureModes: [
      'Thinking gradient descent finds the global minimum — it finds A minimum, not THE minimum',
      'Confusing contour lines (constant value) with gradient arrows (direction of steepest ascent)',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "Gradient descent, how neural networks learn" (DL Ch. 2)' },
      { type: 'Read', text: 'colah — "Calculus on Computational Graphs: Backpropagation"' },
    ],
    projects: [
      { text: 'Gradient field visualizer (2D contour plots with arrows)' },
    ],
  },
  {
    id: 15, phase: 'p2', title: 'The Chain Rule — This IS Backpropagation',
    status: 'not-started', hours: '4–6h',
    prereqs: [14],
    crossPhaseLinks: [],
    conceptChecks: [
      'Draw a computation graph for L = (wx+b-y)². Trace gradients backward through it.',
      'Why is reverse-mode autodiff (backprop) cheaper than forward-mode for neural networks?',
      'What is the chain rule in one sentence?',
    ],
    failureModes: [
      'Thinking backprop is a separate algorithm from the chain rule — it IS the chain rule on a computation graph',
      'Confusing the forward pass (compute values) with the backward pass (compute gradients)',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "Backpropagation, intuitively" (DL Ch. 3) + "Backpropagation calculus" (Ch. 4)' },
      { type: 'Do', text: 'Draw and manually trace backward through L = (wx+b-y)²' },
    ],
    projects: [],
  },
  {
    id: 16, phase: 'p2', title: 'Optimization and Gradient Descent',
    status: 'not-started', hours: '6–8h',
    prereqs: [15],
    crossPhaseLinks: [8],
    conceptChecks: [
      'What happens when the learning rate is too big? Too small?',
      'What does momentum do and why is it helpful?',
      'Why does Adam work better than vanilla SGD in practice?',
      'What does "convex" mean and why does it make optimization easy?',
    ],
    failureModes: [
      'Thinking SGD always converges — it depends on learning rate, landscape shape, and luck',
      'Confusing batch gradient descent (all data) with SGD (random mini-batches) with full-batch',
    ],
    mvl: [
      { type: 'Watch', text: 'Karpathy — "Building micrograd" (Lecture 1, ~2.5h)' },
      { type: 'Do', text: 'Complete micrograd: Value class with autodiff, train on simple 2D data' },
    ],
    projects: [
      { text: 'micrograd — autograd engine from scratch' },
    ],
  },
  {
    id: 17, phase: 'p2', title: 'Constrained Optimization and Lagrange Multipliers',
    status: 'not-started', hours: '3–5h',
    prereqs: [16],
    crossPhaseLinks: [],
    conceptChecks: [
      'What do Lagrange multipliers do geometrically? (Gradients are parallel at the optimum)',
      'What are KKT conditions and when do you need them?',
      'How is L2 regularization equivalent to a Lagrange constraint on weight magnitude?',
      'What is duality and why do SVMs use the dual formulation?',
    ],
    failureModes: [
      'Memorizing Lagrange multiplier formulas without the geometric insight (gradients must be parallel)',
      'Not seeing that alignment IS constrained optimization: maximize capability SUBJECT TO safety constraints',
    ],
    mvl: [
      { type: 'Watch', text: 'Khan Academy — "Lagrange multipliers, using tangency to solve constrained optimization"' },
      { type: 'Do', text: 'Solve a constrained optimization problem by hand; verify with code' },
    ],
    projects: [],
  },
  {
    id: 18, phase: 'p2', title: 'Loss Landscapes and Local Minima',
    status: 'not-started', hours: '3–4h',
    prereqs: [17],
    crossPhaseLinks: [8, 11],
    conceptChecks: [
      'Why are saddle points more common than local minima in high-dimensional spaces?',
      'What is the double descent phenomenon?',
      'What does the Hessian being positive definite at a point tell you?',
    ],
    failureModes: [
      'Assuming local minima are the main obstacle in neural network optimization — in high dimensions, saddle points dominate',
      'Confusing training loss (how well you fit data) with generalization (how well you perform on new data)',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "But what is a neural network?" (DL Ch. 1)' },
      { type: 'Read', text: 'colah — "Neural Networks, Manifolds, and Topology"' },
    ],
    projects: [
      { text: 'Add 2-parameter loss landscape visualization to micrograd project' },
    ],
  },
  // ─── Phase 3: Probability ───
  {
    id: 19, phase: 'p3', title: 'Probability Distributions and Bayes\' Theorem',
    status: 'not-started', hours: '4–5h',
    prereqs: [],
    crossPhaseLinks: [18],
    conceptChecks: [
      'What is the difference between a PDF and a PMF?',
      'State Bayes\' theorem and explain what prior, likelihood, and posterior mean.',
      'What distribution does a softmax output represent?',
    ],
    failureModes: [
      'Confusing P(A|B) with P(B|A) — the "prosecutor\'s fallacy"',
      'Thinking Bayesian and frequentist probability are incompatible rather than different frameworks',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "Bayes theorem, the geometry of changing beliefs"' },
      { type: 'Do', text: 'Implement Bayes\' theorem for a spam filter' },
    ],
    projects: [
      { text: 'Bayesian spam filter from scratch' },
    ],
  },
  {
    id: 20, phase: 'p3', title: 'Expectation, Variance, and Covariance',
    status: 'not-started', hours: '3–5h',
    prereqs: [19],
    crossPhaseLinks: [8, 9],
    conceptChecks: [
      'What is expected value geometrically (center of mass)?',
      'What does the covariance matrix being positive semi-definite mean?',
      'How is PCA related to eigendecomposition of the covariance matrix?',
    ],
    failureModes: [
      'Confusing covariance (can be any real number) with correlation (normalized to [-1,1])',
      'Forgetting that covariance matrices are always symmetric and PSD — connecting back to Lesson 10',
    ],
    mvl: [
      { type: 'Watch', text: 'StatQuest — "Covariance, Clearly Explained" + "PCA, Step by Step"' },
      { type: 'Do', text: 'Generate correlated 2D data, compute covariance matrix, find PCA directions' },
    ],
    projects: [
      { text: 'PCA from covariance eigenvectors (ties SVD ↔ statistics)' },
    ],
  },
  {
    id: 21, phase: 'p3', title: 'Maximum Likelihood Estimation',
    status: 'not-started', hours: '3–4h',
    prereqs: [19, 20],
    crossPhaseLinks: [16],
    conceptChecks: [
      'What does "maximum likelihood" mean in plain English?',
      'Why do we maximize log-likelihood instead of likelihood?',
      'How is minimizing cross-entropy loss the same as maximizing likelihood?',
    ],
    failureModes: [
      'Confusing likelihood (function of parameters given data) with probability (function of data given parameters)',
      'Missing the critical connection: LLM training objective = maximum likelihood estimation',
    ],
    mvl: [
      { type: 'Read', text: 'MML Book, Chapter 8.3' },
      { type: 'Do', text: 'MLE for a Gaussian: find best μ and σ from data' },
    ],
    projects: [],
  },
  {
    id: 22, phase: 'p3', title: 'Information Theory — Entropy, KL, Cross-Entropy, and Mutual Information',
    status: 'not-started', hours: '4–6h',
    prereqs: [21],
    crossPhaseLinks: [],
    conceptChecks: [
      'What does entropy measure? When is it maximized?',
      'What does KL divergence measure? Is it symmetric?',
      'Write the relationship: cross-entropy = entropy + KL divergence. What does this mean for training?',
      'What does temperature do in softmax?',
    ],
    failureModes: [
      'Thinking KL divergence is a distance metric — it\'s not symmetric! KL(P||Q) ≠ KL(Q||P)',
      'Confusing entropy (uncertainty of a distribution) with cross-entropy (using wrong distribution to encode)',
    ],
    mvl: [
      { type: 'Read', text: 'colah — "Visual Information Theory"' },
      { type: 'Do', text: 'Implement cross-entropy loss from scratch; show it decreases as model improves' },
    ],
    projects: [],
  },
  {
    id: 23, phase: 'p3', title: 'Bayesian Reasoning and Inference',
    status: 'not-started', hours: '5–7h',
    prereqs: [19, 21, 22],
    crossPhaseLinks: [11],
    conceptChecks: [
      'How is L2 regularization equivalent to a Gaussian prior on weights?',
      'What is the difference between MLE and MAP estimation?',
      'What is a likelihood ratio and why is it more intuitive than raw Bayes?',
      'What is Solomonoff induction and why is it uncomputable?',
    ],
    failureModes: [
      'Thinking Bayesian inference = just using Bayes\' theorem — it\'s a whole framework for reasoning under uncertainty',
      'Missing the stunning regularization = Bayesian prior connection (L2 = Gaussian prior, L1 = Laplace prior)',
    ],
    mvl: [
      { type: 'Read', text: 'Yudkowsky — "An Intuitive Explanation of Bayes\' Theorem"' },
      { type: 'Do', text: 'Sequential updating: coin bias posterior converging with more flips' },
    ],
    projects: [
      { text: 'Bayesian sequential updating visualizer' },
    ],
  },
  // ─── Phase 3b: Applied Statistics ───
  {
    id: 24, phase: 'p4', title: 'Hypothesis Testing, P-Values, and What They Actually Mean',
    status: 'not-started', hours: '3–5h',
    prereqs: [23],
    crossPhaseLinks: [],
    conceptChecks: [
      'What does a p-value actually mean? What does it NOT mean?',
      'What is the difference between statistical significance and practical significance?',
      'Why is multiple testing a problem and how do corrections work?',
    ],
    failureModes: [
      'Thinking p < 0.05 means "the result is true" — it means "this unlikely if H₀ were true"',
      'Confusing Type I and Type II errors',
    ],
    mvl: [
      { type: 'Read', text: 'ASA Statement on Statistical Significance and P-Values' },
      { type: 'Do', text: 'Simulate p-hacking: run many t-tests, see false positives accumulate' },
    ],
    projects: [],
  },
  {
    id: 25, phase: 'p4', title: 'Experimental Design and Common Statistical Fallacies',
    status: 'not-started', hours: '3–4h',
    prereqs: [24],
    crossPhaseLinks: [],
    conceptChecks: [
      'Why is random assignment important for causal claims?',
      'What is Simpson\'s paradox and why does it matter?',
      'How does sample size affect the reliability of conclusions?',
    ],
    failureModes: [
      'Assuming observational studies establish causation',
      'Ignoring confounders in natural experiments',
    ],
    mvl: [
      { type: 'Read', text: 'Examples of Simpson\'s paradox in real data' },
      { type: 'Do', text: 'Design an experiment to test a specific ML hypothesis' },
    ],
    projects: [],
  },
  {
    id: 26, phase: 'p4', title: 'Regression — From Linear to Logistic and Beyond',
    status: 'not-started', hours: '4–6h',
    prereqs: [24, 10],
    crossPhaseLinks: [],
    conceptChecks: [
      'How does linear regression connect to projection (Lesson 10)?',
      'What does logistic regression model and why is it used for classification?',
      'What is regularization doing in the Bayesian interpretation?',
    ],
    failureModes: [
      'Treating regression coefficients as causal effects without justification',
      'Applying linear regression to fundamentally nonlinear relationships',
    ],
    mvl: [
      { type: 'Do', text: 'Implement linear regression as projection: x̂ = (AᵀA)⁻¹Aᵀb' },
      { type: 'Do', text: 'Compare L1 vs L2 regularization on a real dataset' },
    ],
    projects: [],
  },
  {
    id: 27, phase: 'p4', title: 'Causal Inference — From Correlation to Causation',
    status: 'not-started', hours: '4–5h',
    prereqs: [25],
    crossPhaseLinks: [],
    conceptChecks: [
      'What is the difference between seeing and doing (Pearl\'s do-calculus)?',
      'What is a DAG and how does it represent causal assumptions?',
      'When can you infer causation from observational data?',
    ],
    failureModes: [
      'Assuming causal direction from correlation alone',
      'Ignoring unobserved confounders',
    ],
    mvl: [
      { type: 'Read', text: 'Pearl\'s "The Book of Why" — Chapters 1–3' },
      { type: 'Do', text: 'Draw causal DAGs for 3 real-world scenarios, identify confounders' },
    ],
    projects: [],
  },
  {
    id: 28, phase: 'p4', title: 'Applied Statistics — Genetics, Epidemiology, and Adjudicating Debates',
    status: 'not-started', hours: '3–4h',
    prereqs: [26, 27],
    crossPhaseLinks: [],
    conceptChecks: [
      'How do you evaluate competing statistical claims in a real controversy?',
      'What makes a meta-analysis stronger than individual studies?',
      'How does effect size complement p-values?',
    ],
    failureModes: [
      'Cherry-picking studies that support a conclusion',
      'Ignoring base rates when evaluating individual studies',
    ],
    mvl: [
      { type: 'Do', text: 'Analyze a real statistical controversy using the tools from this phase' },
    ],
    projects: [],
  },
  // ─── Phase 5a: Differential Equations & Dynamical Systems ───
  {
    id: 29, phase: 'p5', title: 'Introduction to ODEs — Rates of Change as Vector Fields',
    status: 'not-started', hours: '3–4h',
    prereqs: [14],
    crossPhaseLinks: [],
    conceptChecks: [
      'What is the geometric meaning of dx/dt = f(x)? Draw it.',
      'What is a fixed point and how do you classify stability in 1D?',
      'How is Euler\'s method the same as gradient descent?',
      'What is a vector field and what does it mean to "follow the flow"?',
    ],
    failureModes: [
      'Thinking you need to solve ODEs analytically — the geometric/qualitative approach is what matters',
      'Missing the gradient descent connection — every training step IS an Euler step on an ODE',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "Differential equations, studying the unsolvable"' },
      { type: 'Read', text: 'Strogatz "Nonlinear Dynamics and Chaos" — Chapters 1–2' },
      { type: 'Do', text: 'Plot vector fields for 1D and 2D ODEs with matplotlib quiver' },
      { type: 'Do', text: 'Euler\'s method by hand: compare step sizes, relate to learning rate' },
    ],
    projects: [
      { text: 'Vector field plotter for arbitrary 2D systems' },
    ],
  },
  {
    id: 30, phase: 'p5', title: 'Linear Systems and Phase Portraits — Eigenvalues Determine Everything',
    status: 'not-started', hours: '4–5h',
    prereqs: [29, 8],
    crossPhaseLinks: [11],
    conceptChecks: [
      'Given a 2×2 matrix A, classify the phase portrait from its eigenvalues.',
      'What does the condition number κ mean for gradient flow trajectories?',
      'What is the Jacobian and why does it give you local dynamics?',
      'Draw phase portraits for: stable node, saddle, stable spiral, center.',
    ],
    failureModes: [
      'Memorizing the classification without seeing why eigenvalues determine it — always connect to e^{λt}',
      'Confusing Jacobian (linear approximation) with Hessian (second derivatives of loss) — related but distinct',
    ],
    mvl: [
      { type: 'Watch', text: 'Steve Brunton — "Phase Portraits" and "Stability and Eigenvalues" (Dynamical Systems playlist)' },
      { type: 'Read', text: 'Strogatz — Chapter 5 (Linear Systems) and 6.1–6.3 (Phase Plane)' },
      { type: 'Do', text: 'Build the full eigenvalue classification: 5 matrices → predict → simulate → verify' },
      { type: 'Do', text: 'Condition number visualization: gradient flow on L = x² + κy² for κ = 1, 10, 100' },
    ],
    projects: [
      { text: 'Interactive phase portrait classifier: input matrix → eigenvalues → portrait type → animation' },
    ],
  },
  {
    id: 31, phase: 'p5', title: 'Gradient Flow and Training Dynamics — Training as a River',
    status: 'not-started', hours: '4–5h',
    prereqs: [30, 16],
    crossPhaseLinks: [18],
    conceptChecks: [
      'Write the gradient flow ODE. Why does the loss never increase along it?',
      'What is the Euler stability bound for learning rate? Derive it.',
      'Why does momentum help with bad conditioning? Write the second-order ODE.',
      'What is implicit regularization and why does gradient descent find min-norm solutions?',
    ],
    failureModes: [
      'Thinking gradient flow guarantees finding the global minimum — it finds A minimum, determined by initialization',
      'Forgetting that SGD ≠ gradient flow — the stochasticity matters and breaks some continuous-time guarantees',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "Gradient descent, how neural networks learn" (re-watch with ODE eyes)' },
      { type: 'Watch', text: 'Steve Brunton — "Gradient Systems and Lyapunov Functions"' },
      { type: 'Read', text: 'Gabriel Goh — "Why Momentum Really Works" (Distill)' },
      { type: 'Do', text: 'Gradient flow vs discrete GD on 2D losses: round bowl, elongated bowl, double well' },
      { type: 'Do', text: 'Learning rate stability experiment: find the divergence boundary' },
    ],
    projects: [
      { text: 'Momentum visualization: vanilla GD vs momentum on elongated loss' },
    ],
  },
  {
    id: 32, phase: 'p5', title: 'Stability, Lyapunov Functions, and Phase Transitions',
    status: 'not-started', hours: '4–5h',
    prereqs: [31],
    crossPhaseLinks: [48],
    conceptChecks: [
      'What is a Lyapunov function and how does it prove stability without solving the ODE?',
      'Name the three major 1D bifurcation types and sketch their diagrams.',
      'What is grokking and how is it a phase transition in training dynamics?',
      'Could a Lyapunov function prove AI safety? What would it need to satisfy?',
    ],
    failureModes: [
      'Thinking bifurcations are exotic — learning rate as bifurcation parameter is immediate and practical',
      'Confusing phase transitions (qualitative change) with gradual improvement (quantitative change)',
    ],
    mvl: [
      { type: 'Watch', text: 'Steve Brunton — "Stability and Lyapunov Functions" and "Bifurcations"' },
      { type: 'Watch', text: 'Veritasium — "The Logistic Map and the Route to Chaos"' },
      { type: 'Read', text: 'Strogatz — Chapter 3 (Bifurcations) and Chapter 8.1–8.2 (Lyapunov)' },
      { type: 'Read', text: 'Power et al. — "Grokking: Generalization Beyond Overfitting"' },
      { type: 'Do', text: 'Bifurcation diagrams for saddle-node and pitchfork bifurcations' },
    ],
    projects: [
      { text: 'Grokking dynamics: train on modular arithmetic, plot the phase transition' },
    ],
  },
  {
    id: 33, phase: 'p5', title: 'Neural ODEs and Stochastic Dynamics',
    status: 'not-started', hours: '3–5h',
    prereqs: [32],
    crossPhaseLinks: [42],
    conceptChecks: [
      'How is a ResNet related to Euler discretization of an ODE?',
      'What is the adjoint method and why does it save memory?',
      'What SDE approximates SGD? What role does noise play?',
      'Why does large learning rate favor flat minima?',
    ],
    failureModes: [
      'Thinking neural ODEs replaced transformers — they\'re conceptually important but not dominant in practice',
      'Treating SGD noise as purely harmful — it\'s a feature that helps find generalizing solutions',
    ],
    mvl: [
      { type: 'Watch', text: 'Yannic Kilcher — "Neural Ordinary Differential Equations" (paper review)' },
      { type: 'Watch', text: 'Steve Brunton — "Neural ODEs" (Data-Driven Dynamical Systems)' },
      { type: 'Read', text: 'Chen et al. — "Neural Ordinary Differential Equations" (2018)' },
      { type: 'Do', text: 'Neural ODE toy implementation on spiral dataset with torchdiffeq' },
      { type: 'Do', text: 'SDE simulation: Euler-Maruyama on double-well potential, vary noise' },
    ],
    projects: [
      { text: 'Flat vs sharp minima: demonstrate learning rate selects minimum type' },
    ],
  },
  // ─── Phase 5b: Additional Foundations ───
  {
    id: 34, phase: 'p5', title: 'Computability and Complexity — The Limits of Knowledge',
    status: 'not-started', hours: '4–6h',
    prereqs: [23],
    crossPhaseLinks: [],
    conceptChecks: [
      'Can you explain the halting problem proof (diagonal argument)?',
      'What does Rice\'s theorem say you CANNOT do about programs in general?',
      'What is Kolmogorov complexity and why is it uncomputable?',
      'Why is AIXI uncomputable? What does it have to do with Solomonoff induction?',
      'What is VC dimension and how does it relate to sample complexity?',
    ],
    failureModes: [
      'Thinking Rice\'s theorem means you can\'t verify ANYTHING — it\'s about GENERAL verifiers, not specific proofs',
      'Confusing computability (what\'s possible) with complexity (what\'s feasible)',
    ],
    mvl: [
      { type: 'Watch', text: 'Computerphile — "Halting Problem" and "Turing Machines Explained"' },
      { type: 'Read', text: 'Scott Aaronson — "Who Can Name the Bigger Number?"' },
      { type: 'Do', text: 'Rice\'s theorem application: list 5 alignment properties, explain why each is undecidable in general' },
    ],
    projects: [
      { text: 'Kolmogorov complexity estimation: shortest programs for 5 different strings' },
    ],
  },
  {
    id: 35, phase: 'p5', title: 'Abstract Algebra — Groups, Symmetry, and Neural Networks',
    status: 'not-started', hours: '4–6h',
    prereqs: [8, 9],
    crossPhaseLinks: [48],
    conceptChecks: [
      'What are the four axioms of a group? Give three concrete examples.',
      'Why does permuting hidden neurons give the same function? What group is this?',
      'What is the orbit-stabilizer theorem and why do singularities occur when stabilizers are large?',
      'How does weight space symmetry create the singularities that SLT studies?',
    ],
    failureModes: [
      'Thinking groups are purely abstract — they literally describe neural network symmetry',
      'Confusing the group (the symmetries) with the set being acted upon (the weight space)',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — groups and symmetry video' },
      { type: 'Read', text: '"Visual Group Theory" by Nathan Carter — Chapters 1-4' },
      { type: 'Do', text: 'Write out the multiplication table for S₃, find identity and inverses' },
      { type: 'Do', text: 'Demonstrate neuron permutation invariance in a PyTorch network' },
    ],
    projects: [
      { text: 'Orbit counting for networks with identical vs distinct neurons' },
    ],
  },
  {
    id: 36, phase: 'p5', title: 'Topology and Manifolds — The Shape of Data and Loss',
    status: 'not-started', hours: '4–6h',
    prereqs: [18],
    crossPhaseLinks: [48],
    conceptChecks: [
      'What is the manifold hypothesis and why does it explain deep learning\'s success?',
      'How does a ReLU layer divide space into flat regions?',
      'What is a homeomorphism? Why is topology "geometry without measurement"?',
      'What is resolution of singularities and why does SLT need it?',
    ],
    failureModes: [
      'Thinking topology is too abstract to be useful — the manifold hypothesis is concretely testable',
      'Confusing intrinsic dimension (of the manifold) with ambient dimension (of the embedding space)',
    ],
    mvl: [
      { type: 'Read', text: 'colah\'s blog — "Neural Networks, Manifolds, and Topology"' },
      { type: 'Do', text: 'Swiss roll: PCA fails, t-SNE succeeds — see the manifold structure' },
      { type: 'Do', text: 'Train a classifier on concentric circles, visualize layer-by-layer untangling' },
    ],
    projects: [
      { text: 'Intrinsic dimensionality estimation of MNIST / word embeddings' },
    ],
  },
  {
    id: 37, phase: 'p5', title: 'Formal Logic — Self-Reference, Incompleteness, and the Limits of Reason',
    status: 'not-started', hours: '4–5h',
    prereqs: [34],
    crossPhaseLinks: [],
    conceptChecks: [
      'State Gödel\'s first incompleteness theorem informally. What does it say can\'t be done?',
      'What is Löb\'s theorem and why does it obstruct AI self-trust?',
      'How does the diagonal argument appear in both the halting problem and Gödel\'s theorem?',
      'What is logical uncertainty and why is it different from empirical uncertainty?',
    ],
    failureModes: [
      'Thinking incompleteness means math is broken — it means formal systems have inherent limits',
      'Over-applying Gödel (it applies to formal systems strong enough for arithmetic, not to everything)',
    ],
    mvl: [
      { type: 'Watch', text: 'Veritasium — "Math Has a Fatal Flaw"' },
      { type: 'Read', text: '"Gödel\'s Proof" by Nagel & Newman (100 pages, very clear)' },
      { type: 'Do', text: 'Write a Python quine — self-reference made concrete' },
    ],
    projects: [
      { text: 'Löb\'s theorem thought exercise: why can\'t an AI prove its own alignment?' },
    ],
  },
  // ─── Phase 6: Neural Networks ───
  {
    id: 38, phase: 'p6', title: 'How a Single Neuron Works',
    status: 'not-started', hours: '3–4h',
    prereqs: [10],
    crossPhaseLinks: [15, 16],
    conceptChecks: [
      'What are the three steps a single neuron computes?',
      'Why can\'t a single neuron learn XOR?',
      'Why did ReLU largely replace sigmoid/tanh?',
      'What is the universal approximation theorem? What doesn\'t it tell you?',
    ],
    failureModes: [
      'Thinking "universal approximation" means any network can learn anything — it says nothing about LEARNING, only representation',
      'Forgetting that a neuron IS a dot product + nonlinearity — you already know both pieces from Lessons 10 + calculus',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "But what is a neural network?" (DL Ch. 1)' },
      { type: 'Do', text: 'Single neuron classification on 2D data: see the decision boundary' },
    ],
    projects: [
      { text: 'Activation function explorer: visualize sigmoid, tanh, ReLU, GELU' },
    ],
  },
  {
    id: 39, phase: 'p6', title: 'The Forward Pass as Matrix Multiplications',
    status: 'not-started', hours: '4–6h',
    prereqs: [38],
    crossPhaseLinks: [4, 5],
    conceptChecks: [
      'Write the forward pass of a 3-layer MLP as a sequence of matrix operations.',
      'What is a hidden representation? How does each layer transform it?',
      'Why do we need nonlinearities between layers?',
    ],
    failureModes: [
      'Losing track of dimensions — always write shapes explicitly: (batch, features) × (features, hidden)',
      'Treating the forward pass as a black box — you should be able to compute any output by hand for a tiny network',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "But what is a neural network?" (DL Ch. 1, re-watch matrix section)' },
      { type: 'Do', text: 'Build a 3-layer MLP in NumPy (no framework), manually trace dimensions' },
    ],
    projects: [],
  },
  {
    id: 40, phase: 'p6', title: 'Backpropagation Through the Full Network',
    status: 'not-started', hours: '6–8h',
    prereqs: [39, 15],
    crossPhaseLinks: [],
    conceptChecks: [
      'Draw the computation graph for a 2-layer MLP and trace gradients backward.',
      'Why is reverse-mode AD (backprop) cheaper than forward-mode for neural networks?',
      'What is the vanishing gradient problem and how do skip connections help?',
    ],
    failureModes: [
      'Thinking backprop is mysterious — it\'s just the chain rule applied to a computation graph',
      'Confusing the forward pass (compute values) with the backward pass (compute gradients)',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "Backpropagation" (DL Ch. 3) + "Backpropagation calculus" (Ch. 4)' },
      { type: 'Watch', text: 'Andrej Karpathy — "micrograd" (builds autograd from scratch)' },
      { type: 'Do', text: 'Full backprop by hand on a 2-layer MLP for one data point, verify with PyTorch' },
    ],
    projects: [
      { text: 'Build micrograd: minimal autograd engine from scratch' },
    ],
  },
  {
    id: 41, phase: 'p6', title: 'Attention — Dot Products in Action',
    status: 'not-started', hours: '6–8h',
    prereqs: [40, 10],
    crossPhaseLinks: [9],
    conceptChecks: [
      'Write the attention equation. What is Q, K, V and what does each do?',
      'Why divide by √d_k? What goes wrong if you don\'t?',
      'How is attention like a soft dictionary lookup?',
      'What is multi-head attention and why does it help?',
    ],
    failureModes: [
      'Memorizing the attention formula without understanding that QK^T computes similarity scores',
      'Forgetting that attention weights are just softmaxed dot products — you learned dot products in Lesson 10',
    ],
    mvl: [
      { type: 'Watch', text: '3B1B — "Attention in transformers, visually explained"' },
      { type: 'Read', text: 'Jay Alammar — "The Illustrated Transformer"' },
      { type: 'Do', text: 'Implement single-head attention from scratch in PyTorch, visualize attention patterns' },
    ],
    projects: [
      { text: 'Attention pattern visualizer for a small trained model' },
    ],
  },
  {
    id: 42, phase: 'p6', title: 'Building a Transformer from Scratch',
    status: 'not-started', hours: '8–10h',
    prereqs: [41],
    crossPhaseLinks: [],
    conceptChecks: [
      'What are the components of a transformer block (in order)?',
      'What does layer normalization do and why is it needed?',
      'What is the residual stream and why does it matter for interpretability?',
      'What are positional encodings and why does the transformer need them?',
    ],
    failureModes: [
      'Building a transformer without understanding each piece — trace data flow through every component',
      'Treating the residual stream as incidental — it\'s the central communication channel and the key interpretability concept',
    ],
    mvl: [
      { type: 'Watch', text: 'Andrej Karpathy — "Let\'s build GPT from scratch"' },
      { type: 'Do', text: 'Build a character-level GPT from scratch, train on Shakespeare' },
    ],
    projects: [
      { text: 'Working GPT trained on a text corpus with interpretable attention patterns' },
    ],
  },
  {
    id: 43, phase: 'p6', title: 'Reinforcement Learning Foundations',
    status: 'not-started', hours: '6–8h',
    prereqs: [40],
    crossPhaseLinks: [19, 20],
    conceptChecks: [
      'What is a Markov Decision Process? Define states, actions, rewards, transitions.',
      'What is the Bellman equation and why is it recursive?',
      'What is a policy gradient and how does REINFORCE work?',
      'What is PPO and why is it used in RLHF?',
    ],
    failureModes: [
      'Getting lost in RL taxonomy — focus on policy gradients since that\'s what RLHF uses',
      'Thinking RLHF is just RL — the "HF" (human feedback) part changes the reward structure fundamentally',
    ],
    mvl: [
      { type: 'Watch', text: 'Mutual Information — "RLHF Explained"' },
      { type: 'Read', text: 'Spinning Up in Deep RL (OpenAI) — core concepts' },
      { type: 'Do', text: 'Implement REINFORCE on CartPole from scratch' },
    ],
    projects: [
      { text: 'Policy gradient on a simple environment with reward visualization' },
    ],
  },
  {
    id: 44, phase: 'p6', title: 'The LLM Training Pipeline — From Raw Text to Aligned AI',
    status: 'not-started', hours: '6–8h',
    prereqs: [42, 43],
    crossPhaseLinks: [21, 22],
    conceptChecks: [
      'What are the three stages of LLM training and what does each optimize?',
      'Why is cross-entropy the right loss for next-token prediction? (Connect to MLE + info theory)',
      'What is the KL penalty in RLHF and why is it there?',
      'What is Constitutional AI and how does it differ from standard RLHF?',
    ],
    failureModes: [
      'Treating the pipeline as three disconnected steps — each builds on the previous and the math connects',
      'Underestimating how much the training pipeline IS alignment — RLHF is an alignment technique',
    ],
    mvl: [
      { type: 'Watch', text: 'Andrej Karpathy — "State of GPT" talk' },
      { type: 'Read', text: 'Anthropic — "Constitutional AI" paper' },
      { type: 'Do', text: 'Trace the full pipeline: what mathematical concept from which lesson is used at each stage?' },
    ],
    projects: [
      { text: 'End-to-end pipeline diagram with mathematical annotations' },
    ],
  },
  // ─── Phase 7: Interpretability ───
  {
    id: 45, phase: 'p7', title: 'What Interpretability Researchers Actually Do',
    status: 'not-started', hours: '4–6h',
    prereqs: [42],
    crossPhaseLinks: [11, 9],
    conceptChecks: [
      'What is the residual stream hypothesis?',
      'What is a feature direction in activation space?',
      'What is the superposition hypothesis? Why does it make interp hard?',
      'What is a sparse autoencoder and how does it find features?',
    ],
    failureModes: [
      'Thinking interp is just "looking at attention patterns" — it\'s much deeper and more mathematical',
      'Forgetting that you already know the math: features = directions (Lesson 2), superposition = overcomplete basis (Lesson 3), SAEs = projections (Lesson 10)',
    ],
    mvl: [
      { type: 'Read', text: 'Neel Nanda — "A Comprehensive Mechanistic Interpretability Explainer"' },
      { type: 'Read', text: 'Anthropic — "Toy Models of Superposition"' },
      { type: 'Do', text: 'Use TransformerLens to extract residual stream activations and run PCA' },
    ],
    projects: [],
  },
  {
    id: 46, phase: 'p7', title: 'Circuits and Features in Practice',
    status: 'not-started', hours: '8–10h',
    prereqs: [45],
    crossPhaseLinks: [4, 8],
    conceptChecks: [
      'What is an induction head and how does it implement in-context learning?',
      'How do QK and OV circuits compose across layers?',
      'What does it mean to "read off" a feature from the residual stream?',
    ],
    failureModes: [
      'Getting overwhelmed by the mechanistic details — start with induction heads, the simplest complete circuit',
      'Thinking circuits are fixed — they\'re descriptions of behavior patterns, not hardwired structures',
    ],
    mvl: [
      { type: 'Read', text: 'Elhage et al. — "A Mathematical Framework for Transformer Circuits"' },
      { type: 'Read', text: 'Olsson et al. — "In-context Learning and Induction Heads"' },
      { type: 'Do', text: 'Find and verify an induction head in a small transformer using TransformerLens' },
    ],
    projects: [
      { text: 'Induction head detector and visualizer' },
    ],
  },
  {
    id: 47, phase: 'p7', title: 'Scaling Laws, Emergent Capabilities, and Phase Transitions',
    status: 'not-started', hours: '6–8h',
    prereqs: [46],
    crossPhaseLinks: [32],
    conceptChecks: [
      'What are Chinchilla scaling laws and what do they predict?',
      'What are emergent capabilities and why are they controversial?',
      'How do phase transitions in training relate to scaling?',
    ],
    failureModes: [
      'Treating emergent capabilities as magical — they may be measurement artifacts or genuine phase transitions',
      'Ignoring that scaling laws are empirical fits — they could break at any point',
    ],
    mvl: [
      { type: 'Read', text: 'Kaplan et al. — "Scaling Laws for Neural Language Models"' },
      { type: 'Read', text: 'Wei et al. — "Emergent Abilities of Large Language Models"' },
      { type: 'Do', text: 'Plot known scaling law data. Extrapolate. Where does the fit break?' },
    ],
    projects: [],
  },
  {
    id: 48, phase: 'p7', title: 'Singular Learning Theory — The Geometry of Learning',
    status: 'not-started', hours: '8–12h',
    prereqs: [47, 35, 36],
    crossPhaseLinks: [32],
    conceptChecks: [
      'What is a singularity in weight space? Give an example in a simple neural network.',
      'What is the RLCT (λ) and how does it generalize the number of parameters?',
      'How does the Local Learning Coefficient (LLC) track phase transitions during training?',
      'Why does SLT say Bayesian model comparison works differently for neural networks vs regular models?',
    ],
    failureModes: [
      'Trying to learn SLT without the prerequisites — it synthesizes algebra (symmetry), topology (singularities), calculus (integration), and dynamics (phase transitions)',
      'Getting lost in the algebraic geometry details — focus on the RLCT as "effective dimension" and its implications',
    ],
    mvl: [
      { type: 'Read', text: 'Jesse Hoogland & others — "The Developmental Landscape of In-Context Learning"' },
      { type: 'Watch', text: 'Neel Nanda — SLT research streams (YouTube)' },
      { type: 'Do', text: 'Estimate the LLC for a small model during training, identify phase transitions' },
    ],
    projects: [
      { text: 'LLC tracking during grokking: visualize the phase transition via RLCT' },
    ],
  },
  // ─── Phase 8: Alignment Theory ───
  {
    id: 49, phase: 'p8', title: 'Game Theory Foundations',
    status: 'not-started', hours: '4–6h',
    prereqs: [23],
    crossPhaseLinks: [],
    conceptChecks: [
      'What is a Nash equilibrium? Give an example where it\'s bad for everyone.',
      'What is the prisoner\'s dilemma and why is it relevant to AI alignment?',
      'What are correlated equilibria and mechanism design?',
    ],
    failureModes: [
      'Treating game theory as purely theoretical — it directly models AI-human and AI-AI strategic interactions',
      'Assuming Nash equilibria are "optimal" — they\'re stable, which is different',
    ],
    mvl: [
      { type: 'Read', text: 'Nisan et al. — "Algorithmic Game Theory" (selected chapters)' },
      { type: 'Do', text: 'Implement iterated prisoner\'s dilemma tournament with different strategies' },
    ],
    projects: [],
  },
  {
    id: 50, phase: 'p8', title: 'Decision Theory — CDT, EDT, and FDT',
    status: 'not-started', hours: '5–7h',
    prereqs: [49],
    crossPhaseLinks: [23],
    conceptChecks: [
      'What is Newcomb\'s problem and why do CDT and EDT disagree?',
      'What is Functional Decision Theory and what does it get right?',
      'Why does decision theory matter for AI alignment?',
    ],
    failureModes: [
      'Getting lost in philosophical edge cases — focus on why the decision theory an AI uses matters for safety',
      'Treating this as purely philosophical — decision theory determines agent behavior in concrete scenarios',
    ],
    mvl: [
      { type: 'Read', text: 'Soares & Fallenstein — "Agent Foundations for Aligning Machine Intelligence"' },
      { type: 'Read', text: 'Yudkowsky & Soares — "Functional Decision Theory"' },
    ],
    projects: [],
  },
  {
    id: 51, phase: 'p8', title: 'Anthropics and Self-Locating Beliefs',
    status: 'not-started', hours: '4–6h',
    prereqs: [50],
    crossPhaseLinks: [23],
    conceptChecks: [
      'What is the Sleeping Beauty problem and why does it matter?',
      'What is the Doomsday Argument?',
      'How do anthropic considerations affect AI forecasting?',
    ],
    failureModes: [
      'Dismissing anthropics as navel-gazing — it has concrete implications for AI safety forecasting',
      'Getting stuck on "which is the right answer" — focus on understanding why reasonable people disagree',
    ],
    mvl: [
      { type: 'Read', text: 'Bostrom — "Anthropic Bias" (selected chapters)' },
    ],
    projects: [],
  },
  {
    id: 52, phase: 'p8', title: 'The Alignment Problem — Technical Foundations',
    status: 'not-started', hours: '6–8h',
    prereqs: [51, 45],
    crossPhaseLinks: [44],
    conceptChecks: [
      'What is the difference between outer and inner alignment?',
      'What is a mesa-optimizer and why is it dangerous?',
      'What is deceptive alignment? Under what conditions might it arise?',
      'What is scalable oversight and why is it hard?',
    ],
    failureModes: [
      'Treating alignment as a single problem — it\'s a cluster of related problems requiring different approaches',
      'Being so pessimistic that you don\'t engage with the technical details — the math matters',
    ],
    mvl: [
      { type: 'Read', text: 'Hubinger et al. — "Risks from Learned Optimization"' },
      { type: 'Read', text: 'Amodei et al. — "Concrete Problems in AI Safety"' },
    ],
    projects: [],
  },
  {
    id: 53, phase: 'p8', title: 'Open Problems and Research Frontiers',
    status: 'not-started', hours: '4–6h',
    prereqs: [52],
    crossPhaseLinks: [45, 46, 8],
    conceptChecks: [
      'What is scalable oversight and why is it hard?',
      'What is ELK (Eliciting Latent Knowledge)?',
      'What does Singular Learning Theory study?',
      'Name three open problems in mechanistic interpretability.',
    ],
    failureModes: [
      'Getting overwhelmed by the number of open problems — pick ONE that excites you and go deep',
      'Skipping empirical work in favor of only reading theory — alignment needs both',
    ],
    mvl: [
      { type: 'Read', text: 'Neel Nanda — "200 Concrete Open Problems in Mechanistic Interpretability"' },
      { type: 'Do', text: 'Pick one open problem. Write a 1-page plan for how you\'d approach it.' },
    ],
    projects: [],
  },
];

// Review checkpoints
const CHECKPOINTS = [
  {
    id: 'cp1', afterLesson: 12, phase: 'p1', title: 'Phase 1 Review: LA → ML Bridge',
    exercises: [
      '<strong>Matrix decomposition relay:</strong> Take a 4×4 matrix. Compute rank, determinant, eigenvalues, SVD. For each, state one thing an ML researcher would care about.',
      '<strong>Attention from scratch:</strong> Using ONLY linear algebra (no neural network framing), compute Q·Kᵀ for two 3-dimensional query and key vectors. Explain what the resulting scalar means geometrically.',
      '<strong>Superposition puzzle:</strong> You have 5 features to represent in 3 dimensions. Show that you can\'t make all pairs orthogonal. Find an arrangement that minimizes maximum dot product between any pair.',
    ],
  },
  {
    id: 'cp2', afterLesson: 18, phase: 'p2', title: 'Phase 2 Review: Calculus → Training Bridge',
    exercises: [
      '<strong>Full backprop trace:</strong> Given a 2-layer MLP with specific weights, compute the forward pass AND backward pass by hand for one data point. Verify your gradients numerically.',
      '<strong>Loss landscape connection:</strong> Create a 2-parameter loss function. Visualize gradient descent with different learning rates. Connect to eigenvalues of the Hessian.',
      '<strong>Chain rule to circuits:</strong> Draw the computation graph for attention (QK dot product → softmax → weighted sum of V). Label every edge with what gradient flows through it.',
    ],
  },
  {
    id: 'cp3', afterLesson: 37, phase: 'p3', title: 'Phase 3 Review: Probability + Math Foundations → LLM Training Bridge',
    exercises: [
      '<strong>Full training loop explained:</strong> Starting from MLE, derive why cross-entropy is the loss function for next-token prediction. Connect entropy, KL divergence, and the training objective.',
      '<strong>Regularization unification:</strong> Show that L2 weight decay = Gaussian prior = MAP estimation. Compute the MAP estimate for a simple 1-parameter model.',
      '<strong>Covariance → PCA → SVD:</strong> Generate 3D data with structure. Compute covariance matrix, find eigenvectors (PCA), compare with SVD of the centered data matrix. Show they give the same principal directions.',
    ],
  },
  {
    id: 'cp4', afterLesson: 44, phase: 'p6', title: 'Phase 4 Review: Everything → Transformer Bridge',
    exercises: [
      '<strong>Mathematical audit:</strong> Open your GPT code. For every matrix multiplication, state: the input/output dimensions, the rank of the weight matrix, what information bottleneck it creates.',
      '<strong>Attention as projection:</strong> Show that attention is a form of weighted projection. Connect attention weights → linear combinations (Lesson 3) → projections (Lesson 10).',
      '<strong>End-to-end pipeline:</strong> Trace a model from pre-training (MLE, cross-entropy) through SFT (distribution shift) to RLHF (policy gradient + KL penalty). For each stage, name the math concepts and which lesson covers them.',
    ],
  },
  {
    id: 'cp5', afterLesson: 48, phase: 'p7', title: 'Phase 5 Review: Interp → Alignment Bridge',
    exercises: [
      '<strong>Feature geometry:</strong> In TransformerLens, extract residual stream activations for 100 inputs. Run PCA. Interpret the top 3 components. Connect to eigenvectors (Lesson 8) and change of basis (Lesson 11).',
      '<strong>Superposition quantification:</strong> For a set of feature directions found by an SAE, compute pairwise cosine similarities. Visualize as a heatmap. How orthogonal are they?',
      '<strong>Scaling + SLT connection:</strong> How would you use the Local Learning Coefficient (LLC) to detect when a model acquires a new capability during training? What would a phase transition look like in an LLC plot?',
    ],
  },
  {
    id: 'cp6', afterLesson: 53, phase: 'p8', title: 'Phase 6 Review: Full Integration',
    exercises: [
      '<strong>Alignment scenario analysis:</strong> A model trained with RLHF shows unexpected behavior in deployment. Using game theory (what strategies are at play?), decision theory (what decision procedure is the model using?), Bayesian reasoning (what\'s your posterior that it\'s deceptive?), and interpretability (what would you look for internally?) — write a full analysis.',
      '<strong>Mathematical connections map:</strong> Create a concept map connecting at least 15 specific concepts from across all 6 phases. Each connection should be a concrete statement, not just "related to."',
    ],
  },
];

const LAYOUT = {
  width: 1300,
  height: 1200,
  nodes: {
    // Phase 0 - setup (top-left)
    0:  { x: 60,  y: 30 },
    1:  { x: 60,  y: 110 },
    // Phase 1 - linear algebra (left column)
    2:  { x: 60,  y: 210 },
    3:  { x: 60,  y: 290 },
    4:  { x: 60,  y: 370 },
    5:  { x: 170, y: 370 },
    6:  { x: 115, y: 460 },
    7:  { x: 15,  y: 460 },
    8:  { x: 60,  y: 550 },
    9:  { x: 60,  y: 640 },
    10: { x: 180, y: 640 },
    11: { x: 120, y: 730 },
    12: { x: 60,  y: 820 },
    // Phase 2 - calculus (center-left)
    'p2-0': { x: 300, y: 200 },
    13: { x: 300, y: 280 },
    14: { x: 300, y: 370 },
    15: { x: 300, y: 460 },
    16: { x: 300, y: 550 },
    17: { x: 300, y: 640 },
    18: { x: 300, y: 730 },
    // Phase 3 - probability (center)
    19: { x: 470, y: 110 },
    20: { x: 470, y: 210 },
    21: { x: 470, y: 310 },
    22: { x: 470, y: 410 },
    23: { x: 470, y: 510 },
    // Phase 4 - statistics (center, below P3)
    24: { x: 470, y: 630 },
    25: { x: 470, y: 710 },
    26: { x: 470, y: 790 },
    27: { x: 470, y: 870 },
    28: { x: 470, y: 950 },
    // Phase 5a - diff eq & dynamical systems (center-right, top)
    29: { x: 640, y: 110 },
    30: { x: 640, y: 200 },
    31: { x: 640, y: 290 },
    32: { x: 640, y: 380 },
    33: { x: 640, y: 470 },
    // Phase 5b - additional foundations (center-right, bottom)
    34: { x: 640, y: 590 },
    35: { x: 640, y: 680 },
    36: { x: 640, y: 770 },
    37: { x: 640, y: 860 },
    // Phase 6 - neural networks (right)
    38: { x: 830, y: 110 },
    39: { x: 830, y: 210 },
    40: { x: 830, y: 310 },
    41: { x: 830, y: 420 },
    42: { x: 830, y: 530 },
    43: { x: 830, y: 640 },
    44: { x: 830, y: 750 },
    // Phase 7 - interpretability (far right)
    45: { x: 1000, y: 370 },
    46: { x: 1000, y: 490 },
    47: { x: 1000, y: 610 },
    48: { x: 1000, y: 730 },
    // Phase 8 - alignment theory (far right, top)
    49: { x: 1170, y: 110 },
    50: { x: 1170, y: 220 },
    51: { x: 1170, y: 330 },
    52: { x: 1170, y: 440 },
    53: { x: 1170, y: 550 },
  },
};


// ═══════════════════════════════════════════════
// CALENDAR STATE
// ═══════════════════════════════════════════════

const CALENDAR_KEY = 'alignment-curriculum-calendar';
let calYear = new Date().getFullYear();
let calMonth = new Date().getMonth();
let calSelectedDate = null;
let calDragLesson = null;

function loadCalendar() {
  try { return JSON.parse(localStorage.getItem(CALENDAR_KEY)) || {}; } catch(e) { return {}; }
}
function saveCalendar(cal) { localStorage.setItem(CALENDAR_KEY, JSON.stringify(cal)); }
function dateKey(y, m, d) { return `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`; }

function getScheduledDayCounts() {
  const cal = loadCalendar();
  const counts = {};
  Object.values(cal).forEach(ids => ids.forEach(id => { counts[id] = (counts[id] || 0) + 1; }));
  return counts;
}


// ═══════════════════════════════════════════════
// RENDERING ENGINE
// ═══════════════════════════════════════════════

let currentView = 'dependency';
let selectedLesson = null;

const STATUS_KEY = 'alignment-curriculum-statuses';
const STATUS_CYCLE = ['not-started', 'in-progress', 'complete'];

function loadStatuses() {
  try {
    const saved = JSON.parse(localStorage.getItem(STATUS_KEY));
    if (saved) LESSONS.forEach(l => { if (saved[l.id] !== undefined) l.status = saved[l.id]; });
  } catch(e) {}
}

function saveStatuses() {
  const obj = {};
  LESSONS.forEach(l => obj[l.id] = l.status);
  localStorage.setItem(STATUS_KEY, JSON.stringify(obj));
}

function cycleStatus(id, ev) {
  if (ev) ev.stopPropagation();
  const lesson = LESSONS.find(l => l.id === id);
  const idx = STATUS_CYCLE.indexOf(lesson.status);
  lesson.status = STATUS_CYCLE[(idx + 1) % 3];
  saveStatuses();
  refreshAll();
  if (selectedLesson === id) selectLesson(id);
}

function updateStats() {
  const total = LESSONS.length;
  const complete = LESSONS.filter(l => l.status === 'complete').length;
  const inProgress = LESSONS.filter(l => l.status === 'in-progress').length;
  document.getElementById('stat-complete').textContent = complete;
  document.getElementById('stat-total').textContent = total;
  document.getElementById('progress-fill').style.width = `${(complete / total) * 100}%`;

  function parseHours(h) {
    const m = h.match(/(\d+)–(\d+)/);
    return m ? (parseInt(m[1]) + parseInt(m[2])) / 2 : 5;
  }
  let done = 0, remaining = 0;
  LESSONS.forEach(l => {
    const h = parseHours(l.hours);
    if (l.status === 'complete') done += h;
    else remaining += h;
  });
  document.getElementById('stat-hours-done').textContent = Math.round(done);
  document.getElementById('stat-hours-left').textContent = Math.round(remaining);
}

function refreshAll() {
  renderSidebar();
  if (currentView === 'dependency') renderGraph();
  else if (currentView === 'timeline') renderTimeline();
  else if (currentView === 'calendar') renderCalendar();
  updateStats();
}

function getPhaseColor(phaseId) {
  const p = PHASES.find(ph => ph.id === phaseId);
  return p ? p.color : '#888';
}

function getStatusColor(status) {
  if (status === 'complete') return 'var(--complete)';
  if (status === 'in-progress') return 'var(--in-progress)';
  return 'var(--not-started)';
}

// ── Sidebar ──
function renderSidebar() {
  const sidebar = document.getElementById('sidebar');
  let html = '';
  PHASES.forEach(phase => {
    const phaseLessons = LESSONS.filter(l => l.phase === phase.id);
    html += `<div class="nav-section-header" onclick="toggleSection('${phase.id}')" style="color:${phase.color}">
      <span class="chevron" id="chev-${phase.id}">▾</span> ${phase.name.toUpperCase()}
    </div>`;
    html += `<div id="section-${phase.id}">`;
    phaseLessons.forEach(lesson => {
      html += `<div class="nav-item" id="nav-item-${lesson.id}" onclick="selectLesson(${lesson.id})">
        <div class="status-dot" style="background:${getStatusColor(lesson.status)}" onclick="cycleStatus(${lesson.id}, event)" title="Click to cycle status"></div>
        <span style="font-family:'JetBrains Mono',monospace;font-size:10px;opacity:0.5;width:22px">${lesson.label || lesson.id}</span>
        ${lesson.title}
      </div>`;
    });
    // Checkpoint
    const cp = CHECKPOINTS.find(c => c.phase === phase.id);
    if (cp) {
      html += `<div class="nav-item-checkpoint" onclick="selectCheckpoint('${cp.id}')">✎ ${cp.title}</div>`;
    }
    html += `</div>`;
  });
  sidebar.innerHTML = html;
}

function toggleSection(phaseId) {
  const section = document.getElementById(`section-${phaseId}`);
  const chev = document.getElementById(`chev-${phaseId}`);
  const hidden = section.style.display === 'none';
  section.style.display = hidden ? '' : 'none';
  chev.classList.toggle('collapsed', !hidden);
}

// ── Dependency Map ──
function renderGraph() {
  const svg = document.getElementById('graph-svg');
  const rect = svg.parentElement.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  const scaleX = w / LAYOUT.width;
  const scaleY = h / LAYOUT.height;
  const scale = Math.min(scaleX, scaleY) * 0.88;
  const offsetX = (w - LAYOUT.width * scale) / 2 + 20;
  const offsetY = (h - LAYOUT.height * scale) / 2 + 10;

  function tx(x) { return x * scale + offsetX; }
  function ty(y) { return y * scale + offsetY; }

  let edgesHtml = '';
  let nodesHtml = '';

  LESSONS.forEach(lesson => {
    const to = LAYOUT.nodes[lesson.id];
    lesson.prereqs.forEach(prereqId => {
      const from = LAYOUT.nodes[prereqId];
      edgesHtml += `<line class="edge" id="edge-${prereqId}-${lesson.id}" x1="${tx(from.x)}" y1="${ty(from.y)}" x2="${tx(to.x)}" y2="${ty(to.y)}" />`;
    });
    lesson.crossPhaseLinks.forEach(linkId => {
      const from = LAYOUT.nodes[linkId];
      if (from) {
        edgesHtml += `<line class="edge edge-cross-phase" id="xedge-${linkId}-${lesson.id}" x1="${tx(from.x)}" y1="${ty(from.y)}" x2="${tx(to.x)}" y2="${ty(to.y)}" />`;
      }
    });
  });

  LESSONS.forEach(lesson => {
    const pos = LAYOUT.nodes[lesson.id];
    const color = getPhaseColor(lesson.phase);
    const r = 18;
    const statusColor = getStatusColor(lesson.status);
    const fillOpacity = lesson.status === 'complete' ? 0.25 : lesson.status === 'in-progress' ? 0.15 : 0.08;

    nodesHtml += `<g class="node-group" onclick="selectLesson(${lesson.id})" id="node-${lesson.id}">
      <circle class="node-circle" cx="${tx(pos.x)}" cy="${ty(pos.y)}" r="${r}" fill="${color}" fill-opacity="${fillOpacity}" stroke="${statusColor}" />
      <text class="node-number" x="${tx(pos.x)}" y="${ty(pos.y) + 4}" fill="${lesson.status === 'not-started' ? color : statusColor}">${lesson.label || lesson.id}</text>
    </g>`;
  });

  const phaseLabels = [
    { x: 60,   y: 5,   color: '#94a3b8', label: 'P0 SETUP' },
    { x: 100,  y: 180, color: '#6ee7b7', label: 'P1 LINEAR ALGEBRA' },
    { x: 300,  y: 170, color: '#818cf8', label: 'P2 CALCULUS' },
    { x: 470,  y: 80,  color: '#f9a8d4', label: 'P3 PROBABILITY' },
    { x: 470,  y: 600, color: '#f472b6', label: 'P4 STATISTICS' },
    { x: 640,  y: 80,  color: '#e879f9', label: 'P5 MATH ENRICHMENT' },
    { x: 830,  y: 80,  color: '#fbbf24', label: 'P6 NEURAL NETWORKS' },
    { x: 1000, y: 340, color: '#38bdf8', label: 'P7 INTERPRETABILITY' },
    { x: 1170, y: 80,  color: '#c084fc', label: 'P8 ALIGNMENT' },
  ];

  let labelsHtml = '';
  phaseLabels.forEach(pl => {
    labelsHtml += `<text x="${tx(pl.x)}" y="${ty(pl.y)}" fill="${pl.color}" opacity="0.3" font-family="JetBrains Mono, monospace" font-size="10" font-weight="700" letter-spacing="2" text-anchor="middle">${pl.label}</text>`;
  });

  svg.innerHTML = labelsHtml + edgesHtml + nodesHtml;
}

// ── Select Lesson ──
function selectLesson(id) {
  selectedLesson = id;
  const lesson = LESSONS.find(l => l.id === id);
  if (!lesson) return;

  // Sidebar highlight
  document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
  const navItem = document.getElementById(`nav-item-${id}`);
  if (navItem) navItem.classList.add('active');

  // Edge highlighting (only in dependency view)
  if (currentView === 'dependency') {
    document.querySelectorAll('.edge').forEach(el => el.classList.remove('highlighted'));
    lesson.prereqs.forEach(pid => {
      const edge = document.getElementById(`edge-${pid}-${id}`);
      if (edge) edge.classList.add('highlighted');
    });
    lesson.crossPhaseLinks.forEach(lid => {
      const edge = document.getElementById(`xedge-${lid}-${id}`);
      if (edge) edge.classList.add('highlighted');
    });
    LESSONS.forEach(other => {
      if (other.prereqs.includes(id)) {
        const edge = document.getElementById(`edge-${id}-${other.id}`);
        if (edge) edge.classList.add('highlighted');
      }
    });
  }

  // Build detail panel
  const phase = PHASES.find(p => p.id === lesson.phase);
  let html = '';

  html += `<div class="detail-header">
    <div class="detail-phase-tag" style="color:${phase.color}">
      <div style="background:${phase.color};width:6px;height:6px;border-radius:50%"></div>
      Phase ${phase.id.replace('p','')} · ${phase.name}
    </div>
    <div class="detail-title">Lesson ${lesson.label || lesson.id}: ${lesson.title}</div>
    <div class="detail-meta">
      <div>⏱ <strong>${lesson.hours}</strong></div>
      <div>Status: <strong style="color:${getStatusColor(lesson.status)};cursor:pointer;border-bottom:1px dashed" onclick="cycleStatus(${lesson.id}, event)" title="Click to change">${lesson.status.replace('-', ' ')}</strong></div>
    </div>
  </div>`;

  // Prerequisites
  html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">⬆</span> Prerequisites</div>`;
  if (lesson.prereqs.length === 0 && lesson.crossPhaseLinks.length === 0) {
    html += `<p style="font-size:13px;color:var(--text-dim)">None — entry point</p>`;
  } else {
    html += `<ul class="prereq-list">`;
    lesson.prereqs.forEach(pid => {
      const p = LESSONS.find(l => l.id === pid);
      html += `<li><span class="prereq-link" onclick="selectLesson(${pid})">Lesson ${p.label || pid}</span>: ${p.title} <span style="color:${getStatusColor(p.status)};font-size:11px">(${p.status.replace('-',' ')})</span></li>`;
    });
    lesson.crossPhaseLinks.forEach(lid => {
      const l = LESSONS.find(ls => ls.id === lid);
      if (l) {
        html += `<li style="opacity:0.7"><span class="prereq-link" onclick="selectLesson(${lid})">Lesson ${l.label || lid}</span>: ${l.title} <span style="font-size:11px;color:var(--text-dim)">(cross-phase)</span></li>`;
      }
    });
    html += `</ul>`;
  }
  html += `</div>`;

  // MVL
  html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">⚡</span> Minimum Viable Lesson</div>`;
  lesson.mvl.forEach(r => {
    html += `<div class="mvl-resource"><div class="res-type">${r.type}</div>${r.text}</div>`;
  });
  html += `</div>`;

  // Concept checks
  html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">✓</span> Concept Checks</div><ul class="concept-check-list">`;
  lesson.conceptChecks.forEach(q => { html += `<li>${q}</li>`; });
  html += `</ul></div>`;

  // Failure modes
  html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">⚠</span> Common Failure Modes</div><ul class="failure-list">`;
  lesson.failureModes.forEach(f => { html += `<li>${f}</li>`; });
  html += `</ul></div>`;

  // Projects
  if (lesson.projects.length > 0) {
    html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">🔨</span> Coding Projects</div><ul class="project-list">`;
    lesson.projects.forEach(p => {
      html += `<li class="project-item"><span class="project-badge ${p.label.toLowerCase()}">${p.label}</span><span>${p.text}</span></li>`;
    });
    html += `</ul></div>`;
  }

  document.getElementById('detail-empty').style.display = 'none';
  document.getElementById('detail-content').style.display = 'block';
  document.getElementById('detail-content').innerHTML = html;

  // Mobile: show as bottom sheet
  if (window.innerWidth <= 900) {
    document.getElementById('detail-panel').classList.add('mobile-open');
    document.getElementById('detail-backdrop').classList.add('visible');
    document.getElementById('detail-backdrop').classList.add('open');
  }
}

function selectCheckpoint(cpId) {
  const cp = CHECKPOINTS.find(c => c.id === cpId);
  if (!cp) return;

  let html = `<div class="detail-header">
    <div class="detail-phase-tag" style="color:${getPhaseColor(cp.phase)}">
      <div style="background:${getPhaseColor(cp.phase)};width:6px;height:6px;border-radius:50%"></div>
      Review Checkpoint
    </div>
    <div class="detail-title">${cp.title}</div>
  </div>
  <div class="detail-section"><div class="detail-section-title"><span class="icon">🔗</span> Integration Exercises</div><ul class="concept-check-list">`;
  cp.exercises.forEach(ex => { html += `<li>${ex}</li>`; });
  html += `</ul></div>`;

  document.getElementById('detail-empty').style.display = 'none';
  document.getElementById('detail-content').style.display = 'block';
  document.getElementById('detail-content').innerHTML = html;

  if (window.innerWidth <= 900) {
    document.getElementById('detail-panel').classList.add('mobile-open');
    document.getElementById('detail-backdrop').classList.add('visible');
    document.getElementById('detail-backdrop').classList.add('open');
  }
}

function closeMobileDetail() {
  document.getElementById('detail-panel').classList.remove('mobile-open');
  document.getElementById('detail-backdrop').classList.remove('visible');
  document.getElementById('detail-backdrop').classList.remove('open');
}

// ── View Switching ──
function setView(view) {
  currentView = view;
  document.querySelectorAll('.canvas-btn').forEach(b => b.classList.remove('active'));
  event.target.classList.add('active');

  const svg = document.getElementById('graph-svg');
  const calView = document.getElementById('calendar-view');
  const legend = document.getElementById('canvas-legend');
  const mobileDep = document.getElementById('mobile-dependency');
  const mobileTl = document.getElementById('mobile-timeline');
  const isMobile = window.innerWidth <= 900;

  // Hide everything first
  svg.style.display = 'none';
  calView.style.display = 'none';
  legend.style.display = 'none';
  mobileDep.style.display = 'none';
  mobileTl.style.display = 'none';

  if (view === 'dependency') {
    if (isMobile) {
      mobileDep.style.display = 'block';
      renderMobileDependency();
    } else {
      svg.style.display = '';
      legend.style.display = 'flex';
      renderGraph();
    }
  } else if (view === 'timeline') {
    if (isMobile) {
      mobileTl.style.display = 'block';
      renderMobileTimeline();
    } else {
      svg.style.display = '';
      renderTimeline();
    }
  } else if (view === 'calendar') {
    calView.style.display = '';
    renderCalendar();
  }
}

// ── Pace Tracker State ──
const PACE_KEY = 'alignment-curriculum-pace';
const CURRICULUM_START = '2026-02-21'; // First lesson date

// Difficulty weights by phase (relative to Phase 1 baseline)
// Based on: 6-year math gap, strong intuition, rusty mechanics
const DIFFICULTY_WEIGHT = {
  p0: 0.8, p1: 1.0, p2: 1.2, p3: 1.3, p4: 1.3,
  p5: 1.5, p6: 1.4, p7: 1.6, p8: 1.4
};

function loadPaceData() {
  try { return JSON.parse(localStorage.getItem(PACE_KEY)) || { completions: {}, startDate: CURRICULUM_START }; }
  catch(e) { return { completions: {}, startDate: CURRICULUM_START }; }
}
function savePaceData(data) { localStorage.setItem(PACE_KEY, JSON.stringify(data)); }

function recordCompletion(lessonId) {
  const data = loadPaceData();
  if (!data.completions[lessonId]) {
    data.completions[lessonId] = new Date().toISOString();
    savePaceData(data);
  }
}

function computePace() {
  const data = loadPaceData();
  const start = new Date(data.startDate);
  const now = new Date();
  const daysSinceStart = Math.max(1, (now - start) / (1000 * 60 * 60 * 24));

  // Sum content hours completed (using avg of lo-hi range)
  let completedContentHours = 0;
  LESSONS.forEach(l => {
    if (l.status === 'complete') {
      const hrs = parseHoursGlobal(l.hours);
      completedContentHours += hrs.avg;
    }
  });

  // Your actual pace: content hours per calendar day
  const paceHoursPerDay = completedContentHours / daysSinceStart;

  // Compute weighted remaining hours
  let weightedRemainLo = 0, weightedRemainHi = 0;
  LESSONS.forEach(l => {
    if (l.status !== 'complete') {
      const hrs = parseHoursGlobal(l.hours);
      const weight = DIFFICULTY_WEIGHT[l.phase] || 1.3;
      weightedRemainLo += hrs.lo * weight;
      weightedRemainHi += hrs.hi * weight;
    }
  });

  // Estimated days remaining
  const daysRemainLo = paceHoursPerDay > 0 ? Math.round(weightedRemainLo / paceHoursPerDay) : Infinity;
  const daysRemainHi = paceHoursPerDay > 0 ? Math.round(weightedRemainHi / paceHoursPerDay) : Infinity;

  // Projected completion dates
  const projLo = new Date(now.getTime() + daysRemainLo * 24 * 60 * 60 * 1000);
  const projHi = new Date(now.getTime() + daysRemainHi * 24 * 60 * 60 * 1000);

  return {
    daysSinceStart: Math.round(daysSinceStart),
    completedContentHours: Math.round(completedContentHours),
    paceHoursPerDay: paceHoursPerDay.toFixed(1),
    weightedRemainLo: Math.round(weightedRemainLo),
    weightedRemainHi: Math.round(weightedRemainHi),
    daysRemainLo, daysRemainHi,
    projLo, projHi
  };
}

function parseHoursGlobal(h) {
  const match = String(h).match(/(\d+)–(\d+)/);
  if (match) return { lo: parseInt(match[1]), hi: parseInt(match[2]), avg: (parseInt(match[1]) + parseInt(match[2])) / 2 };
  return { lo: 5, hi: 5, avg: 5 };
}

function formatDate(d) {
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  return `${months[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
}

// ── Timeline ──
function renderTimeline() {
  const svg = document.getElementById('graph-svg');
  const rect = svg.parentElement.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  function parseHours(h) {
    const match = String(h).match(/(\d+)–(\d+)/);
    if (match) return { lo: parseInt(match[1]), hi: parseInt(match[2]), avg: (parseInt(match[1]) + parseInt(match[2])) / 2 };
    return { lo: 5, hi: 5, avg: 5 };
  }

  // Compute totals
  let doneLo = 0, doneHi = 0, remainLo = 0, remainHi = 0, inProgLo = 0, inProgHi = 0;
  LESSONS.forEach(l => {
    const hrs = parseHours(l.hours);
    if (l.status === 'complete') { doneLo += hrs.lo; doneHi += hrs.hi; }
    else if (l.status === 'in-progress') { inProgLo += hrs.lo; inProgHi += hrs.hi; }
    else { remainLo += hrs.lo; remainHi += hrs.hi; }
  });
  const totalRemainLo = remainLo + inProgLo;
  const totalRemainHi = remainHi + inProgHi;
  const totalLo = doneLo + inProgLo + remainLo;
  const totalHi = doneHi + inProgHi + remainHi;
  const pctDone = Math.round(((doneLo + doneHi) / 2) / ((totalLo + totalHi) / 2) * 100);

  // Dynamic pace calculation
  const pace = computePace();

  let html = '';
  const cx = w / 2;

  // ── Big summary at top with pace data ──
  if (pace.completedContentHours > 0 && pace.daysRemainLo !== Infinity) {
    html += `<text x="${cx}" y="35" fill="var(--text-bright)" font-family="JetBrains Mono, monospace" font-size="24" font-weight="700" text-anchor="middle">${pace.weightedRemainLo}–${pace.weightedRemainHi} weighted hours remaining</text>`;
    html += `<text x="${cx}" y="58" fill="var(--accent-1)" font-family="JetBrains Mono, monospace" font-size="13" text-anchor="middle">Est. completion: ${formatDate(pace.projLo)} – ${formatDate(pace.projHi)}</text>`;
    html += `<text x="${cx}" y="78" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="11" text-anchor="middle">${pace.completedContentHours}h done in ${pace.daysSinceStart} days · ${pace.paceHoursPerDay}h/day pace · ${pctDone}% complete · difficulty-adjusted</text>`;
  } else {
    html += `<text x="${cx}" y="40" fill="var(--text-bright)" font-family="JetBrains Mono, monospace" font-size="26" font-weight="700" text-anchor="middle">${totalRemainLo}–${totalRemainHi} hours remaining</text>`;
    html += `<text x="${cx}" y="68" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="12" text-anchor="middle">${doneLo}–${doneHi}h complete · ${pctDone}% of curriculum · Complete lessons to activate pace tracker</text>`;
  }

  // ── Phase breakdown ──
  const margin = { top: 105, left: 60, right: 40 };
  const phaseW = w - margin.left - margin.right;
  const rowH = 52;

  PHASES.filter(p => p.id !== 'p9').forEach((phase, i) => {
    const pLessons = LESSONS.filter(l => l.phase === phase.id);
    const complete = pLessons.filter(l => l.status === 'complete').length;
    const inProg = pLessons.filter(l => l.status === 'in-progress').length;
    const total = pLessons.length;
    let pDoneLo = 0, pDoneHi = 0, pTotalLo = 0, pTotalHi = 0;
    pLessons.forEach(l => {
      const hrs = parseHours(l.hours);
      pTotalLo += hrs.lo; pTotalHi += hrs.hi;
      if (l.status === 'complete') { pDoneLo += hrs.lo; pDoneHi += hrs.hi; }
    });
    const pRemLo = pTotalLo - pDoneLo;
    const pRemHi = pTotalHi - pDoneHi;
    const weight = DIFFICULTY_WEIGHT[phase.id] || 1.0;
    const pWeightedRemLo = Math.round(pRemLo * weight);
    const pWeightedRemHi = Math.round(pRemHi * weight);
    const pPct = total > 0 ? (complete / total) : 0;
    const pPctInProg = total > 0 ? (inProg / total) : 0;

    const y = margin.top + i * rowH;
    const barX = margin.left + 200;
    const barW = phaseW - 200 - 180;
    const barH = 16;
    const barY = y + 6;

    // Phase name with difficulty weight
    html += `<text x="${margin.left}" y="${y + 18}" fill="${phase.color}" font-family="JetBrains Mono, monospace" font-size="11" font-weight="600">${phase.name}</text>`;
    html += `<text x="${margin.left}" y="${y + 32}" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="10">${complete}/${total} lessons · ${weight}× difficulty</text>`;

    // Bar background
    html += `<rect x="${barX}" y="${barY}" width="${barW}" height="${barH}" fill="var(--border)" rx="4" opacity="0.3" />`;
    if (pPct > 0) {
      html += `<rect x="${barX}" y="${barY}" width="${barW * pPct}" height="${barH}" fill="${phase.color}" rx="4" opacity="0.7" />`;
    }
    if (pPctInProg > 0) {
      html += `<rect x="${barX + barW * pPct}" y="${barY}" width="${barW * pPctInProg}" height="${barH}" fill="${phase.color}" rx="4" opacity="0.3" />`;
    }

    // Hours remaining with weighted estimate
    let hoursText;
    if (pRemLo === 0 && pRemHi === 0) {
      hoursText = '✓ done';
    } else {
      hoursText = `${pWeightedRemLo}–${pWeightedRemHi}h (adj.)`;
    }
    html += `<text x="${barX + barW + 12}" y="${y + 20}" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="10">${hoursText}</text>`;
  });

  // ── Per-lesson bars at bottom ──
  const bottomY = margin.top + PHASES.filter(p => p.id !== 'p9').length * rowH + 30;
  html += `<text x="${margin.left}" y="${bottomY}" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="10" font-weight="600">HOURS PER LESSON (colored by phase)</text>`;

  const barAreaTop = bottomY + 15;
  const barAreaH = h - barAreaTop - 40;
  const barW = Math.min(16, (phaseW) / LESSONS.length - 1);
  const gap = (phaseW - barW * LESSONS.length) / LESSONS.length;
  const maxH = Math.max(...LESSONS.map(l => parseHours(l.hours).hi));

  LESSONS.forEach((lesson, i) => {
    const x = margin.left + i * (barW + gap) + gap / 2;
    const hrs = parseHours(lesson.hours);
    const barH = (hrs.avg / maxH) * barAreaH;
    const y = barAreaTop + barAreaH - barH;
    const color = getPhaseColor(lesson.phase);
    const opacity = lesson.status === 'complete' ? 0.8 : lesson.status === 'in-progress' ? 0.5 : 0.2;

    html += `<rect x="${x}" y="${y}" width="${barW}" height="${barH}" fill="${color}" opacity="${opacity}" rx="2" cursor="pointer" onclick="selectLesson(${typeof lesson.id === 'string' ? '\'' + lesson.id + '\'' : lesson.id})" />`;
    if (barW >= 10) {
      html += `<text x="${x + barW/2}" y="${barAreaTop + barAreaH + 13}" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="8" text-anchor="middle">${lesson.label || lesson.id}</text>`;
    }
  });

  svg.innerHTML = html;
}

// ── Mobile Dependency View ──
function renderMobileDependency() {
  const container = document.getElementById('mobile-dependency');

  // Track which phases are collapsed
  if (!window._mdCollapsed) window._mdCollapsed = {};

  const completedIds = new Set(LESSONS.filter(l => l.status === 'complete').map(l => l.id));

  let html = '';

  PHASES.filter(p => p.id !== 'p9').forEach(phase => {
    const pLessons = LESSONS.filter(l => l.phase === phase.id);
    const complete = pLessons.filter(l => l.status === 'complete').length;
    const total = pLessons.length;
    const isCollapsed = window._mdCollapsed[phase.id] || false;
    const allDone = complete === total;

    html += `<div class="md-phase">`;
    html += `<div class="md-phase-header${isCollapsed ? ' collapsed' : ''}" onclick="toggleMdPhase('${phase.id}')">
      <span class="md-phase-name" style="color:${phase.color}">${phase.name}</span>
      <div class="md-phase-right">
        <span class="md-phase-progress">${allDone ? '✓' : complete + '/' + total}</span>
        <span class="md-phase-chevron">▼</span>
      </div>
    </div>`;

    html += `<div class="md-phase-body${isCollapsed ? ' collapsed' : ''}">`;
    pLessons.forEach(l => {
      const statusColor = getStatusColor(l.status);
      const statusIcon = l.status === 'complete' ? '✓' : l.status === 'in-progress' ? '◐' : '';
      const statusIconColor = l.status === 'complete' ? '#000' : l.status === 'in-progress' ? '#000' : 'transparent';

      // Check prereqs
      const prereqsMet = l.prereqs.every(p => completedIds.has(p));
      const prereqLabels = l.prereqs.length > 0
        ? l.prereqs.map(p => {
            const pl = LESSONS.find(x => x.id === p);
            return (pl ? (pl.label || pl.id) : p);
          }).join(', ')
        : '';

      html += `<div class="md-lesson-card" onclick="selectLesson(${typeof l.id === 'string' ? '\'' + l.id + '\'' : l.id})">`;

      // Status toggle button
      html += `<button class="md-status-btn" style="border-color:${statusColor};background:${l.status !== 'not-started' ? statusColor : 'transparent'};color:${statusIconColor}" onclick="event.stopPropagation();cycleStatus(${typeof l.id === 'string' ? '\'' + l.id + '\'' : l.id});renderMobileDependency()">${statusIcon}</button>`;

      // Lesson info
      html += `<div class="md-lesson-info">`;
      html += `<span class="md-lesson-name"><span class="md-lesson-num" style="color:${phase.color}">${l.label || l.id}</span>${l.title}</span>`;
      html += `<div class="md-lesson-meta">`;
      html += `<span class="md-lesson-hours">${l.hours}</span>`;
      if (prereqLabels) {
        html += `<span class="md-lesson-prereqs ${prereqsMet ? 'md-prereq-met' : ''}">needs: ${prereqLabels}</span>`;
      }
      html += `</div></div>`;

      html += `<span class="md-lesson-chevron">›</span>`;
      html += `</div>`;
    });
    html += '</div></div>';
  });

  container.innerHTML = html;
}

function toggleMdPhase(phaseId) {
  if (!window._mdCollapsed) window._mdCollapsed = {};
  window._mdCollapsed[phaseId] = !window._mdCollapsed[phaseId];
  renderMobileDependency();
}

// ── Mobile Timeline ──
function renderMobileTimeline() {
  const container = document.getElementById('mobile-timeline');

  function parseHours(h) {
    const match = String(h).match(/(\d+)–(\d+)/);
    if (match) return { lo: parseInt(match[1]), hi: parseInt(match[2]), avg: (parseInt(match[1]) + parseInt(match[2])) / 2 };
    return { lo: 5, hi: 5, avg: 5 };
  }

  // Totals
  let doneLo = 0, doneHi = 0, remainLo = 0, remainHi = 0;
  LESSONS.forEach(l => {
    const hrs = parseHours(l.hours);
    if (l.status === 'complete') { doneLo += hrs.lo; doneHi += hrs.hi; }
    else { remainLo += hrs.lo; remainHi += hrs.hi; }
  });
  const totalLo = doneLo + remainLo;
  const totalHi = doneHi + remainHi;
  const pctDone = Math.round(((doneLo + doneHi) / 2) / ((totalLo + totalHi) / 2) * 100);
  const pace = computePace();

  let html = '<div class="mt-header">';
  if (pace.completedContentHours > 0 && pace.daysRemainLo !== Infinity) {
    html += `<h2>${pace.weightedRemainLo}–${pace.weightedRemainHi}h left</h2>`;
    html += `<div class="mt-subtitle">Est. ${formatDate(pace.projLo)} – ${formatDate(pace.projHi)}</div>`;
    html += `<div class="mt-meta">${pace.completedContentHours}h in ${pace.daysSinceStart}d · ${pace.paceHoursPerDay}h/day · ${pctDone}%</div>`;
  } else {
    html += `<h2>${remainLo}–${remainHi}h remaining</h2>`;
    html += `<div class="mt-meta">${doneLo}–${doneHi}h done · ${pctDone}% complete</div>`;
  }
  html += '</div>';

  PHASES.filter(p => p.id !== 'p9').forEach(phase => {
    const pLessons = LESSONS.filter(l => l.phase === phase.id);
    const complete = pLessons.filter(l => l.status === 'complete').length;
    const total = pLessons.length;
    const pPct = total > 0 ? (complete / total) : 0;
    let pRemLo = 0, pRemHi = 0;
    pLessons.forEach(l => {
      if (l.status !== 'complete') {
        const hrs = parseHours(l.hours);
        const w = DIFFICULTY_WEIGHT[phase.id] || 1.0;
        pRemLo += Math.round(hrs.lo * w);
        pRemHi += Math.round(hrs.hi * w);
      }
    });
    const hoursText = pRemLo === 0 ? '✓' : `${pRemLo}–${pRemHi}h`;

    html += `<div class="mt-phase">`;
    html += `<div class="mt-phase-header">
      <span class="mt-phase-name" style="color:${phase.color}">${phase.name}</span>
      <span class="mt-phase-stats">${complete}/${total} · ${hoursText}</span>
    </div>`;
    html += `<div class="mt-phase-bar"><div class="mt-phase-bar-fill" style="width:${pPct * 100}%;background:${phase.color};opacity:0.7"></div></div>`;
    html += `<div class="mt-phase-lessons">`;
    pLessons.forEach(l => {
      const statusColor = getStatusColor(l.status);
      html += `<div class="mt-lesson" onclick="selectLesson(${typeof l.id === 'string' ? '\'' + l.id + '\'' : l.id})">
        <span class="mt-lesson-status" style="background:${statusColor}"></span>
        <span class="mt-lesson-num" style="color:${phase.color}">${l.label || l.id}</span>
        <span class="mt-lesson-title">${l.title}</span>
        <span class="mt-lesson-hours">${l.hours}</span>
      </div>`;
    });
    html += '</div></div>';
  });

  container.innerHTML = html;
}

// ── Calendar ──
function renderCalendar() {
  const container = document.getElementById('calendar-view');
  const cal = loadCalendar();
  const today = new Date();
  const todayKey = dateKey(today.getFullYear(), today.getMonth(), today.getDate());

  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
  const firstDow = new Date(calYear, calMonth, 1).getDay(); // 0=Sun

  let html = '';

  // Header with nav
  html += `<div class="cal-header">
    <div>
      <span class="cal-month-label">${monthNames[calMonth]} ${calYear}</span>
      <button onclick="calToday()" style="background:none;border:1px solid var(--border);color:var(--text-dim);font-family:'JetBrains Mono',monospace;font-size:10px;padding:2px 8px;border-radius:3px;cursor:pointer;margin-left:10px;vertical-align:middle">today</button>
    </div>
    <div style="display:flex;gap:4px">
      <button class="cal-nav" onclick="calPrev()">&larr;</button>
      <button class="cal-nav" onclick="calNext()">&rarr;</button>
    </div>
  </div>`;

  // Day-of-week headers
  html += `<div class="cal-grid">`;
  ['SUN','MON','TUE','WED','THU','FRI','SAT'].forEach(d => {
    html += `<div class="cal-dow">${d}</div>`;
  });

  // Empty cells before month start
  for (let i = 0; i < firstDow; i++) {
    html += `<div class="cal-day empty"></div>`;
  }

  // Day cells
  for (let d = 1; d <= daysInMonth; d++) {
    const dk = dateKey(calYear, calMonth, d);
    const isToday = dk === todayKey;
    const isSelected = dk === calSelectedDate;
    const dayLessons = (cal[dk] || []).map(id => LESSONS.find(l => l.id === id)).filter(Boolean);

    let classes = 'cal-day';
    if (isToday) classes += ' today';
    if (isSelected) classes += ' selected';

    html += `<div class="${classes}" onclick="calSelectDay('${dk}')" ondragover="event.preventDefault();this.classList.add('drag-over')" ondragleave="this.classList.remove('drag-over')" ondrop="calDrop(event,'${dk}')">`;
    html += `<div class="cal-day-num">${d}</div>`;

    dayLessons.forEach(lesson => {
      const color = getPhaseColor(lesson.phase);
      html += `<div class="cal-chip" style="background:${color}22;color:${color}" onclick="event.stopPropagation();calChipClick(${lesson.id},'${dk}')" title="${lesson.title} — click to view, right-click to remove" oncontextmenu="event.preventDefault();event.stopPropagation();calRemoveLesson(${lesson.id},'${dk}')">`;
      html += `<span class="cal-chip-num">${lesson.label || lesson.id}</span>`;
      html += `<span class="cal-chip-title">${lesson.title}</span>`;
      html += `</div>`;
    });

    html += `</div>`;
  }

  // Empty cells after month end
  const totalCells = firstDow + daysInMonth;
  const remaining = (7 - totalCells % 7) % 7;
  for (let i = 0; i < remaining; i++) {
    html += `<div class="cal-day empty"></div>`;
  }

  html += `</div>`;

  // Lesson pool - always shows all lessons
  const dayCounts = getScheduledDayCounts();
  const unplacedCount = LESSONS.filter(l => !dayCounts[l.id]).length;
  html += `<div class="cal-unscheduled">`;
  html += `<div class="cal-unscheduled-label">LESSON POOL (${unplacedCount} unplaced) — drag onto calendar or select a day and click</div>`;
  html += `<div style="display:flex;flex-wrap:wrap;gap:0">`;

  LESSONS.forEach(lesson => {
    const color = getPhaseColor(lesson.phase);
    const statusIcon = lesson.status === 'complete' ? '●' : lesson.status === 'in-progress' ? '◐' : '○';
    const days = dayCounts[lesson.id] || 0;
    const dimmed = days > 0 ? 'opacity:0.55;' : '';
    html += `<div class="cal-pool-chip" style="background:${color}15;color:${color};${dimmed}" draggable="true" ondragstart="calDragStart(event,${lesson.id})" onclick="calPoolClick(${lesson.id})" title="${lesson.title} (${lesson.hours})${days ? ' — scheduled on ' + days + ' day' + (days>1?'s':'') : ''}">`;
    html += `<span style="font-size:9px">${statusIcon}</span>`;
    html += `<span style="font-family:'JetBrains Mono',monospace;font-size:10px;font-weight:700">${lesson.label || lesson.id}</span>`;
    html += `<span style="font-family:'DM Sans',sans-serif;font-size:11px">${lesson.title}</span>`;
    if (days > 0) html += `<span style="font-family:'JetBrains Mono',monospace;font-size:9px;opacity:0.7;margin-left:2px">${days}d</span>`;
    html += `</div>`;
  });

  html += `</div></div>`;

  container.innerHTML = html;
}

function calPrev() {
  calMonth--;
  if (calMonth < 0) { calMonth = 11; calYear--; }
  renderCalendar();
}
function calNext() {
  calMonth++;
  if (calMonth > 11) { calMonth = 0; calYear++; }
  renderCalendar();
}
function calToday() {
  const t = new Date();
  calYear = t.getFullYear();
  calMonth = t.getMonth();
  renderCalendar();
}

function calSelectDay(dk) {
  calSelectedDate = (calSelectedDate === dk) ? null : dk;
  renderCalendar();

  if (calSelectedDate) {
    // Show picker in detail panel
    showDayPicker(dk);
  }
}

function showDayPicker(dk) {
  const cal = loadCalendar();
  const dayLessonIds = cal[dk] || [];
  const dayLessons = dayLessonIds.map(id => LESSONS.find(l => l.id === id)).filter(Boolean);
  const available = LESSONS.filter(l => !dayLessonIds.includes(l.id));
  const dayCounts = getScheduledDayCounts();

  const parts = dk.split('-');
  const dateStr = new Date(parseInt(parts[0]), parseInt(parts[2])-1, parseInt(parts[3]))
    .toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

  let html = `<div class="detail-header">
    <div class="detail-phase-tag" style="color:var(--accent-5)">
      <div style="background:var(--accent-5);width:6px;height:6px;border-radius:50%"></div>
      Calendar
    </div>
    <div class="detail-title">${dateStr}</div>
  </div>`;

  // Scheduled for this day
  if (dayLessons.length > 0) {
    html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">📅</span> Scheduled</div>`;
    dayLessons.forEach(lesson => {
      const color = getPhaseColor(lesson.phase);
      const otherDays = (dayCounts[lesson.id] || 1) - 1;
      const otherNote = otherDays > 0 ? ` <span style="font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--text-dim)">+${otherDays} other day${otherDays>1?'s':''}</span>` : '';
      html += `<div style="display:flex;align-items:center;gap:8px;padding:6px 0">
        <span style="font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:700;color:${color}">${lesson.label || lesson.id}</span>
        <span style="font-size:12px;flex:1;cursor:pointer" onclick="selectLesson(${lesson.id})">${lesson.title}${otherNote}</span>
        <span style="font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--text-dim)">${lesson.hours}</span>
        <button onclick="calRemoveLesson(${lesson.id},'${dk}')" style="background:none;border:none;color:var(--text-dim);cursor:pointer;font-size:14px;padding:2px 4px" title="Remove from this day">✕</button>
      </div>`;
    });
    html += `</div>`;
  }

  // Add lessons (not already on this day)
  if (available.length > 0) {
    html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">➕</span> Add a Lesson</div>`;

    // Group by phase
    PHASES.forEach(phase => {
      const phaseLessons = available.filter(l => l.phase === phase.id);
      if (phaseLessons.length === 0) return;
      html += `<div style="font-family:'JetBrains Mono',monospace;font-size:9px;font-weight:700;color:${phase.color};letter-spacing:1px;padding:6px 0 2px;opacity:0.6">${phase.name.toUpperCase()}</div>`;
      phaseLessons.forEach(lesson => {
        const color = getPhaseColor(lesson.phase);
        const days = dayCounts[lesson.id] || 0;
        const daysBadge = days > 0 ? `<span style="font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--text-dim);margin-left:4px">${days}d</span>` : '';
        html += `<div class="picker-lesson" onclick="calAddLesson(${lesson.id},'${dk}')">
          <span class="picker-lesson-num" style="color:${color}">${lesson.label || lesson.id}</span>
          <span>${lesson.title}${daysBadge}</span>
          <span class="picker-hours">${lesson.hours}</span>
        </div>`;
      });
    });
    html += `</div>`;
  }

  document.getElementById('detail-empty').style.display = 'none';
  document.getElementById('detail-content').style.display = 'block';
  document.getElementById('detail-content').innerHTML = html;

  if (window.innerWidth <= 900) {
    document.getElementById('detail-panel').classList.add('mobile-open');
    document.getElementById('detail-backdrop').classList.add('open');
  }
}

function calAddLesson(lessonId, dk) {
  const cal = loadCalendar();
  if (!cal[dk]) cal[dk] = [];
  if (!cal[dk].includes(lessonId)) {
    cal[dk].push(lessonId);
    saveCalendar(cal);
  }
  renderCalendar();
  showDayPicker(dk);
}

function calRemoveLesson(lessonId, dk) {
  const cal = loadCalendar();
  if (cal[dk]) {
    cal[dk] = cal[dk].filter(id => id !== lessonId);
    if (cal[dk].length === 0) delete cal[dk];
    saveCalendar(cal);
  }
  renderCalendar();
  if (calSelectedDate === dk) showDayPicker(dk);
}

function calChipClick(lessonId, dk) {
  selectLesson(lessonId);
}

function calPoolClick(lessonId) {
  if (calSelectedDate) {
    calAddLesson(lessonId, calSelectedDate);
  } else {
    selectLesson(lessonId);
  }
}

// Drag and drop
function calDragStart(ev, lessonId) {
  calDragLesson = lessonId;
  ev.dataTransfer.effectAllowed = 'move';
  ev.target.classList.add('dragging');
  setTimeout(() => { if (ev.target) ev.target.classList.remove('dragging'); }, 200);
}

function calDrop(ev, dk) {
  ev.preventDefault();
  ev.target.closest('.cal-day')?.classList.remove('drag-over');
  if (calDragLesson !== null) {
    const cal = loadCalendar();
    // Add to this day (don't remove from other days — lessons can span multiple days)
    if (!cal[dk]) cal[dk] = [];
    if (!cal[dk].includes(calDragLesson)) cal[dk].push(calDragLesson);
    saveCalendar(cal);
    calDragLesson = null;
    renderCalendar();
    if (calSelectedDate === dk) showDayPicker(dk);
  }
}


// ═══════════════════════════════════════════════
// SYNC README TO GITHUB
// ═══════════════════════════════════════════════

const GH_REPO = 'Kaxitron/research_plan';
const GH_README_PATH = 'README.md';
const GH_TOKEN_KEY = 'alignment-curriculum-gh-token';

function getGhToken() {
  let token = localStorage.getItem(GH_TOKEN_KEY);
  if (!token) {
    token = prompt('Enter your GitHub Personal Access Token (stored locally in your browser):');
    if (token) localStorage.setItem(GH_TOKEN_KEY, token.trim());
  }
  return token ? token.trim() : null;
}

// Cache the latest known SHA to avoid stale-SHA conflicts on rapid syncs
let _lastKnownSha = null;
let _syncInProgress = false;

async function syncReadmeToGithub() {
  const btn = document.getElementById('sync-btn');
  const icon = document.getElementById('sync-icon');

  // Prevent overlapping syncs
  if (_syncInProgress) return;
  _syncInProgress = true;
  btn.classList.add('syncing');
  btn.style.pointerEvents = 'none';
  icon.textContent = '⟳';

  try {
    const token = getGhToken();
    if (!token) { _syncInProgress = false; btn.classList.remove('syncing'); btn.style.pointerEvents = ''; icon.textContent = '⬆'; return; }

    // 1. Get current README — use cached SHA header to avoid redundant downloads
    const headers = { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' };
    const getResp = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_README_PATH}`, { headers });
    if (!getResp.ok) throw new Error(`GitHub GET failed: ${getResp.status}`);
    const fileData = await getResp.json();
    const currentSha = fileData.sha;
    let content = new TextDecoder().decode(Uint8Array.from(atob(fileData.content.replace(/\n/g, '')), c => c.charCodeAt(0)));

    // 2. Build status map from current dashboard state
    const statusMap = {};
    LESSONS.forEach(l => {
      const emoji = l.status === 'complete' ? '✅ Complete' :
                    l.status === 'in-progress' ? '🔄 In Progress' : '⬜ Not Started';
      statusMap[l.id] = emoji;
    });

    // 3. Replace status in each table row
    content = content.replace(
      /^\| (\d+) \| (.+?) \| (.+?) \|$/gm,
      (match, id, lessonCol, statusCol) => {
        const numId = parseInt(id);
        if (statusMap.hasOwnProperty(numId)) {
          return `| ${id} | ${lessonCol} | ${statusMap[numId]} |`;
        }
        return match;
      }
    );

    // 4. Push updated README — use freshest SHA (cached from last success, or just fetched)
    const shaToUse = _lastKnownSha || currentSha;
    const encodedContent = btoa(unescape(encodeURIComponent(content)));

    let putResp = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_README_PATH}`, {
      method: 'PUT',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: 'Update lesson progress from dashboard', content: encodedContent, sha: shaToUse })
    });

    // 5. If 409 conflict (stale SHA), re-fetch the latest SHA and retry once
    if (putResp.status === 409) {
      console.log('SHA conflict — refetching and retrying...');
      const retryGet = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_README_PATH}`, { headers });
      if (!retryGet.ok) throw new Error(`GitHub retry GET failed: ${retryGet.status}`);
      const retryData = await retryGet.json();
      putResp = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_README_PATH}`, {
        method: 'PUT',
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: 'Update lesson progress from dashboard', content: encodedContent, sha: retryData.sha })
      });
    }

    if (!putResp.ok) {
      const err = await putResp.json();
      throw new Error(err.message || `GitHub PUT failed: ${putResp.status}`);
    }

    // 6. Cache the new SHA from the successful response
    const putData = await putResp.json();
    if (putData.content && putData.content.sha) {
      _lastKnownSha = putData.content.sha;
    }

    // Success
    btn.classList.remove('syncing');
    btn.classList.add('success');
    icon.textContent = '✓';
    setTimeout(() => { btn.classList.remove('success'); icon.textContent = '⬆'; }, 3000);

  } catch (e) {
    console.error('Sync failed:', e);
    _lastKnownSha = null; // Clear cached SHA on error so next attempt fetches fresh
    btn.classList.remove('syncing');
    btn.classList.add('error');
    icon.textContent = '✗';
    if (e.message.includes('401') || e.message.includes('403')) {
      localStorage.removeItem(GH_TOKEN_KEY);
      alert('Authentication failed — token cleared. Try again with a valid token.');
    } else {
      alert(`Sync failed: ${e.message}`);
    }
    setTimeout(() => { btn.classList.remove('error'); icon.textContent = '⬆'; }, 3000);
  } finally {
    _syncInProgress = false;
    btn.style.pointerEvents = '';
  }
}


// ═══════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════

function refreshCurrentView() {
  const svg = document.getElementById('graph-svg');
  const calView = document.getElementById('calendar-view');
  const legend = document.getElementById('canvas-legend');
  const mobileDep = document.getElementById('mobile-dependency');
  const mobileTl = document.getElementById('mobile-timeline');
  const isMobile = window.innerWidth <= 900;

  svg.style.display = 'none';
  calView.style.display = 'none';
  legend.style.display = 'none';
  mobileDep.style.display = 'none';
  mobileTl.style.display = 'none';

  if (currentView === 'dependency') {
    if (isMobile) { mobileDep.style.display = 'block'; renderMobileDependency(); }
    else { svg.style.display = ''; legend.style.display = 'flex'; renderGraph(); }
  } else if (currentView === 'timeline') {
    if (isMobile) { mobileTl.style.display = 'block'; renderMobileTimeline(); }
    else { svg.style.display = ''; renderTimeline(); }
  } else if (currentView === 'calendar') {
    calView.style.display = '';
    renderCalendar();
  }
}

function init() {
  loadStatuses();
  renderSidebar();
  window.addEventListener('resize', () => {
    // Re-trigger current view on resize to handle mobile <-> desktop transitions
    const fakeEvent = { target: document.querySelector('.canvas-btn.active') };
    const savedView = currentView;
    // Use a small helper instead of setView to avoid event.target issues
    refreshCurrentView();
  });
}

init();
</script>
</body>
</html>

