<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>The Path to AI Alignment — Curriculum Navigator</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@300;400;500;600;700&family=Instrument+Serif:ital@0;1&family=DM+Sans:wght@300;400;500;600;700&display=swap');

  :root {
    --bg: #0a0a0f;
    --bg-raised: #12121a;
    --bg-panel: #16161f;
    --bg-hover: #1e1e2a;
    --border: #2a2a3a;
    --border-bright: #3a3a5a;
    --text: #e0e0ec;
    --text-dim: #8888a0;
    --text-bright: #ffffff;
    --accent-1: #6ee7b7;
    --accent-2: #818cf8;
    --accent-3: #f9a8d4;
    --accent-4: #fbbf24;
    --accent-5: #38bdf8;
    --accent-6: #c084fc;
    --accent-7: #fb923c;
    --complete: #34d399;
    --in-progress: #fbbf24;
    --not-started: #4a4a6a;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'DM Sans', sans-serif;
    overflow: hidden;
    height: 100vh;
  }

  .app {
    display: grid;
    grid-template-columns: 280px 1fr 380px;
    grid-template-rows: auto 1fr;
    height: 100vh;
  }

  /* Header */
  .header {
    grid-column: 1 / -1;
    padding: 14px 24px;
    border-bottom: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: space-between;
    background: var(--bg-raised);
  }
  .header h1 {
    font-family: 'Instrument Serif', serif;
    font-size: 20px;
    font-weight: 400;
    color: var(--text-bright);
  }
  .header h1 span { color: var(--accent-1); }
  .header-stats {
    display: flex;
    gap: 20px;
    font-size: 12px;
    color: var(--text-dim);
  }
  .header-stats .stat-value {
    font-family: 'JetBrains Mono', monospace;
    color: var(--text);
    font-weight: 600;
  }
  .progress-bar-container {
    width: 180px;
    height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }
  .progress-bar-fill {
    height: 100%;
    background: linear-gradient(90deg, var(--accent-1), var(--accent-5));
    border-radius: 2px;
    transition: width 0.5s ease;
  }

  /* Sidebar */
  .sidebar {
    background: var(--bg-raised);
    border-right: 1px solid var(--border);
    overflow-y: auto;
    padding: 12px 0;
  }
  .sidebar::-webkit-scrollbar { width: 4px; }
  .sidebar::-webkit-scrollbar-track { background: transparent; }
  .sidebar::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .nav-section-header {
    padding: 10px 16px 6px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 1.5px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 6px;
    user-select: none;
  }
  .nav-section-header:hover { background: var(--bg-hover); }
  .nav-section-header .chevron {
    transition: transform 0.2s;
    font-size: 8px;
  }
  .nav-section-header .chevron.collapsed { transform: rotate(-90deg); }

  .nav-item {
    padding: 6px 16px 6px 24px;
    font-size: 13px;
    cursor: pointer;
    display: flex;
    align-items: center;
    gap: 8px;
    color: var(--text-dim);
    transition: all 0.15s;
  }
  .nav-item:hover { background: var(--bg-hover); color: var(--text); }
  .nav-item.active { background: var(--bg-hover); color: var(--text-bright); }

  .status-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    flex-shrink: 0;
    cursor: pointer;
    transition: transform 0.15s;
  }
  .status-dot:hover { transform: scale(1.4); }

  .nav-item-checkpoint {
    padding: 5px 16px 5px 32px;
    font-size: 11px;
    color: var(--text-dim);
    cursor: pointer;
    font-style: italic;
    opacity: 0.7;
  }
  .nav-item-checkpoint:hover { opacity: 1; background: var(--bg-hover); }

  /* Main Canvas */
  .main-canvas {
    position: relative;
    overflow: hidden;
    background: var(--bg);
  }
  .canvas-controls {
    position: absolute;
    top: 12px;
    left: 12px;
    z-index: 10;
    display: flex;
    gap: 4px;
    background: var(--bg-raised);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 3px;
  }
  .canvas-btn {
    padding: 5px 12px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    background: transparent;
    color: var(--text-dim);
    border: none;
    border-radius: 4px;
    cursor: pointer;
    transition: all 0.15s;
  }
  .canvas-btn:hover { color: var(--text); background: var(--bg-hover); }
  .canvas-btn.active { color: var(--text-bright); background: var(--bg-hover); }
  .sync-btn {
    background: none; border: 1px solid var(--border); color: var(--text-dim);
    font-family: 'JetBrains Mono', monospace; font-size: 11px;
    padding: 4px 12px; border-radius: 6px; cursor: pointer; white-space: nowrap;
    transition: all 0.2s;
  }
  .sync-btn:hover { color: var(--complete); border-color: var(--complete); }
  .sync-btn.syncing { opacity: 0.5; pointer-events: none; }
  .sync-btn.success { color: var(--complete); border-color: var(--complete); }
  .sync-btn.error { color: #f87171; border-color: #f87171; }

  .canvas-legend {
    position: absolute;
    bottom: 12px;
    left: 12px;
    display: flex;
    gap: 14px;
    font-size: 11px;
    color: var(--text-dim);
    z-index: 10;
  }
  .legend-item { display: flex; align-items: center; gap: 5px; }
  .legend-dot { width: 8px; height: 8px; border-radius: 50%; }

  svg.graph { width: 100%; height: 100%; }

  .edge {
    stroke: var(--border);
    stroke-width: 1.2;
    opacity: 0.4;
    transition: all 0.3s;
  }
  .edge.highlighted { stroke: var(--accent-5); opacity: 0.9; stroke-width: 2; }
  .edge-cross-phase {
    stroke-dasharray: 6 4;
    opacity: 0.2;
  }
  .edge-cross-phase.highlighted { opacity: 0.6; stroke: var(--accent-6); }

  .node-group { cursor: pointer; }
  .node-circle {
    stroke-width: 2;
    transition: all 0.2s;
  }
  .node-group:hover .node-circle { stroke-width: 3; filter: brightness(1.3); }
  .node-number {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    font-weight: 600;
    text-anchor: middle;
    pointer-events: none;
  }

  /* Detail Panel */
  .detail-panel {
    background: var(--bg-panel);
    border-left: 1px solid var(--border);
    overflow-y: auto;
    padding: 20px;
  }
  .detail-panel::-webkit-scrollbar { width: 4px; }
  .detail-panel::-webkit-scrollbar-track { background: transparent; }
  .detail-panel::-webkit-scrollbar-thumb { background: var(--border); border-radius: 2px; }

  .detail-empty {
    height: 100%;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: var(--text-dim);
    font-size: 13px;
    padding: 20px;
  }
  .empty-icon { font-size: 32px; margin-bottom: 12px; opacity: 0.3; }

  .detail-header { margin-bottom: 16px; }
  .detail-phase-tag {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    letter-spacing: 1px;
    display: flex;
    align-items: center;
    gap: 6px;
    margin-bottom: 6px;
  }
  .detail-title {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-bright);
    line-height: 1.3;
    margin-bottom: 8px;
  }
  .detail-meta {
    display: flex;
    gap: 16px;
    font-size: 12px;
    color: var(--text-dim);
  }
  .detail-section {
    margin-bottom: 16px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
  }
  .detail-section-title {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-dim);
    letter-spacing: 0.5px;
    margin-bottom: 8px;
    display: flex;
    align-items: center;
    gap: 6px;
  }
  .detail-section-title .icon { font-size: 13px; }

  .prereq-list, .concept-check-list, .failure-list, .project-list {
    list-style: none;
    padding: 0;
  }
  .prereq-list li, .concept-check-list li, .failure-list li {
    font-size: 12px;
    padding: 4px 0;
    line-height: 1.5;
    color: var(--text);
  }
  .concept-check-list li::before { content: "□ "; color: var(--accent-5); font-weight: bold; }
  .failure-list li::before { content: "⚠ "; }

  .prereq-link {
    color: var(--accent-5);
    cursor: pointer;
    font-weight: 500;
    border-bottom: 1px dashed var(--accent-5);
  }
  .prereq-link:hover { color: var(--text-bright); }

  .mvl-resource {
    font-size: 12px;
    padding: 6px 0;
    line-height: 1.5;
  }
  .res-type {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    font-weight: 700;
    color: var(--accent-4);
    display: inline;
    margin-right: 6px;
  }

  .project-item {
    font-size: 12px;
    padding: 4px 0;
    display: flex;
    align-items: flex-start;
    gap: 6px;
  }
  .project-badge {
    font-family: 'JetBrains Mono', monospace;
    font-size: 8px;
    font-weight: 700;
    padding: 1px 5px;
    border-radius: 3px;
    flex-shrink: 0;
    margin-top: 2px;
  }
  .project-badge.new { background: rgba(56,189,248,0.15); color: var(--accent-5); }
  .project-badge.extends { background: rgba(192,132,252,0.15); color: var(--accent-6); }

  .mobile-close-btn {
    display: none;
    position: sticky;
    top: 0;
    z-index: 10;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    color: var(--text-dim);
    padding: 8px 16px;
    border-radius: 6px;
    cursor: pointer;
    font-family: 'DM Sans', sans-serif;
    font-size: 13px;
    margin-bottom: 12px;
    width: 100%;
  }
  .mobile-close-btn:hover { color: var(--text); background: var(--bg-hover); }

  .detail-backdrop {
    display: none;
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.5);
    z-index: 99;
  }
  .detail-backdrop.open { display: block; }

  /* Responsive */
  @media (max-width: 1100px) {
    .app { grid-template-columns: 240px 1fr 320px; }
  }

  @media (max-width: 900px) {
    .app {
      grid-template-columns: 1fr;
      grid-template-rows: auto 1fr;
    }
    .sidebar { display: none; }
    .header h1 { font-size: 15px; }
    .header-stats { gap: 8px; font-size: 10px; }
    .header { padding: 8px 12px; flex-wrap: wrap; gap: 4px; }
    .progress-bar-container { width: 120px; }
    .main-canvas { overflow: hidden; position: relative; }
    /* Hide SVG on mobile — we use HTML views instead */
    svg.graph { display: none; }
    .canvas-legend { display: none !important; }
    .canvas-controls {
      position: relative;
      top: 0; left: 0;
      margin: 8px;
      width: calc(100% - 16px);
      justify-content: center;
      z-index: 10;
    }
    .canvas-controls .canvas-btn { padding: 8px 14px; font-size: 11px; flex: 1; text-align: center; }

    .detail-panel {
      display: none;
      position: fixed;
      bottom: 0; left: 0; right: 0;
      max-height: 60vh;
      z-index: 100;
      border-left: none;
      border-top: 2px solid var(--accent-5);
      border-radius: 12px 12px 0 0;
      padding: 12px 16px;
      animation: slideUp 0.25s ease;
      overflow-y: auto;
    }
    .detail-panel.mobile-open { display: block; }
    .mobile-close-btn { display: flex; align-items: center; justify-content: center; }
    .detail-backdrop {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.5);
      z-index: 99;
    }
    .detail-backdrop.visible { display: block; }
  }

  /* Mobile HTML view containers (dependency + timeline) */
  .mobile-view {
    display: none;
    position: absolute;
    inset: 0;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    background: var(--bg);
    padding: 60px 14px 20px;
  }
  .mobile-view.active { display: block; }

  /* Legacy alias */
  .mobile-timeline {
    display: none;
    position: absolute;
    inset: 0;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    background: var(--bg);
    padding: 60px 14px 20px;
  }
  .mt-header {
    text-align: center;
    margin-bottom: 20px;
  }
  .mt-header h2 {
    font-family: 'JetBrains Mono', monospace;
    font-size: 20px;
    font-weight: 700;
    color: var(--text-bright);
    margin-bottom: 4px;
  }
  .mt-header .mt-subtitle {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    color: var(--accent-1);
    margin-bottom: 2px;
  }
  .mt-header .mt-meta {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
  }
  .mt-phase {
    margin-bottom: 16px;
    border: 1px solid var(--border);
    border-radius: 8px;
    overflow: hidden;
  }
  .mt-phase-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 10px 12px;
    background: var(--bg-raised);
  }
  .mt-phase-name {
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    font-weight: 600;
  }
  .mt-phase-stats {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
  }
  .mt-phase-bar {
    height: 4px;
    background: var(--border);
  }
  .mt-phase-bar-fill {
    height: 100%;
    border-radius: 0 2px 2px 0;
    transition: width 0.3s ease;
  }
  .mt-phase-lessons {
    padding: 6px 12px;
  }
  .mt-lesson {
    display: flex;
    align-items: center;
    gap: 10px;
    padding: 10px 0;
    font-family: 'JetBrains Mono', monospace;
    font-size: 12px;
    border-bottom: 1px solid var(--border);
    cursor: pointer;
  }
  .mt-lesson:last-child { border-bottom: none; }
  .mt-lesson-num {
    width: 24px;
    text-align: center;
    font-weight: 600;
    font-size: 11px;
    flex-shrink: 0;
  }
  .mt-lesson-title {
    flex: 1;
    color: var(--text);
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .mt-lesson-hours {
    font-size: 9px;
    color: var(--text-dim);
    flex-shrink: 0;
  }
  .mt-lesson-status {
    width: 10px;
    height: 10px;
    border-radius: 50%;
    flex-shrink: 0;
  }

  /* Mobile Dependency View */
  .md-phase {
    margin-bottom: 16px;
  }
  .md-phase-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 14px 16px;
    background: var(--bg-raised);
    border: 1px solid var(--border);
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    user-select: none;
    -webkit-user-select: none;
  }
  .md-phase-header.collapsed { border-radius: 8px; }
  .md-phase-name {
    font-family: 'JetBrains Mono', monospace;
    font-size: 14px;
    font-weight: 700;
  }
  .md-phase-right {
    display: flex;
    align-items: center;
    gap: 10px;
  }
  .md-phase-progress {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
  }
  .md-phase-chevron {
    font-size: 12px;
    color: var(--text-dim);
    transition: transform 0.2s;
  }
  .md-phase-header.collapsed .md-phase-chevron { transform: rotate(-90deg); }
  .md-phase-body {
    border: 1px solid var(--border);
    border-top: none;
    border-radius: 0 0 8px 8px;
    overflow: hidden;
  }
  .md-phase-body.collapsed { display: none; }
  .md-lesson-card {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 12px 14px;
    border-bottom: 1px solid var(--border);
    cursor: pointer;
    transition: background 0.15s;
  }
  .md-lesson-card:last-child { border-bottom: none; }
  .md-lesson-card:active { background: var(--bg-hover); }
  .md-status-btn {
    width: 30px;
    height: 30px;
    border-radius: 50%;
    border: 2px solid;
    background: transparent;
    cursor: pointer;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 12px;
    transition: all 0.15s;
    padding: 0;
  }
  .md-status-btn:active { transform: scale(0.9); }
  .md-lesson-info {
    flex: 1;
    min-width: 0;
  }
  .md-lesson-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 700;
    margin-right: 6px;
  }
  .md-lesson-name {
    font-family: 'JetBrains Mono', monospace;
    font-size: 13px;
    color: var(--text);
    display: block;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  .md-lesson-meta {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-top: 3px;
  }
  .md-lesson-hours {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: var(--text-dim);
  }
  .md-lesson-prereqs {
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: var(--text-dim);
    opacity: 0.7;
  }
  .md-prereq-met { color: var(--complete); opacity: 1; }
  .md-lesson-chevron {
    color: var(--text-dim);
    font-size: 12px;
    flex-shrink: 0;
    opacity: 0.4;
  }

  @keyframes slideUp {
    from { transform: translateY(100%); }
    to { transform: translateY(0); }
  }

  /* Calendar styles */
  .cal-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 16px 20px 12px;
  }
  .cal-nav {
    background: none;
    border: 1px solid var(--border);
    color: var(--text-dim);
    width: 28px;
    height: 28px;
    border-radius: 4px;
    cursor: pointer;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s;
  }
  .cal-nav:hover { color: var(--text); border-color: var(--border-bright); background: var(--bg-hover); }
  .cal-month-label {
    font-family: 'Instrument Serif', serif;
    font-size: 20px;
    color: var(--text-bright);
  }
  .cal-grid {
    display: grid;
    grid-template-columns: repeat(7, 1fr);
    gap: 1px;
    padding: 0 20px 20px;
    flex: 1;
    min-height: 0;
  }
  .cal-dow {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    color: var(--text-dim);
    text-align: center;
    padding: 4px 0 8px;
    letter-spacing: 1px;
  }
  .cal-day {
    background: var(--bg-raised);
    border: 1px solid transparent;
    border-radius: 4px;
    padding: 4px;
    min-height: 72px;
    cursor: pointer;
    transition: all 0.15s;
    position: relative;
    overflow: hidden;
  }
  .cal-day:hover { border-color: var(--border-bright); background: var(--bg-hover); }
  .cal-day.empty { background: transparent; cursor: default; border: none; }
  .cal-day.empty:hover { background: transparent; }
  .cal-day.today { border-color: var(--accent-5); box-shadow: 0 0 0 1px rgba(56,189,248,0.2); }
  .cal-day.selected { border-color: var(--accent-5); background: rgba(56,189,248,0.06); }
  .cal-day-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 11px;
    font-weight: 600;
    color: var(--text-dim);
    margin-bottom: 3px;
  }
  .cal-day.today .cal-day-num { color: var(--accent-5); }
  .cal-chip {
    display: flex;
    align-items: center;
    gap: 3px;
    padding: 2px 5px;
    margin-bottom: 2px;
    border-radius: 3px;
    font-size: 10px;
    font-family: 'JetBrains Mono', monospace;
    cursor: pointer;
    transition: filter 0.15s;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: ellipsis;
  }
  .cal-chip:hover { filter: brightness(1.3); }
  .cal-chip-num {
    font-weight: 700;
    flex-shrink: 0;
  }
  .cal-chip-title {
    font-family: 'DM Sans', sans-serif;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .cal-unscheduled {
    padding: 12px 20px;
    border-top: 1px solid var(--border);
  }
  .cal-unscheduled-label {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 600;
    color: var(--text-dim);
    letter-spacing: 1px;
    margin-bottom: 8px;
  }
  .cal-pool-chip {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 3px 8px;
    margin: 2px 3px;
    border-radius: 4px;
    font-size: 11px;
    cursor: grab;
    transition: all 0.15s;
    border: 1px solid transparent;
    user-select: none;
  }
  .cal-pool-chip:hover { border-color: var(--border-bright); filter: brightness(1.2); }
  .cal-pool-chip.dragging { opacity: 0.5; }
  .cal-day.drag-over { border-color: var(--accent-5) !important; background: rgba(56,189,248,0.1) !important; }

  /* Picker in detail panel */
  .picker-lesson {
    padding: 6px 8px;
    font-size: 12px;
    display: flex;
    align-items: center;
    gap: 8px;
    cursor: pointer;
    border-radius: 4px;
    transition: background 0.15s;
  }
  .picker-lesson:hover { background: var(--bg-hover); }
  .picker-lesson-num {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    font-weight: 700;
    width: 24px;
    text-align: center;
    flex-shrink: 0;
  }
  .picker-hours {
    font-family: 'JetBrains Mono', monospace;
    font-size: 10px;
    color: var(--text-dim);
    margin-left: auto;
  }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <h1>The Path to <span>AI Alignment</span></h1>
    <div class="header-stats">
      <div>
        <span class="stat-value" id="stat-complete">0</span>/<span class="stat-value" id="stat-total">0</span> lessons
        <div class="progress-bar-container">
          <div class="progress-bar-fill" id="progress-fill" style="width:0%"></div>
        </div>
      </div>
      <div>
        ~<span class="stat-value" id="stat-hours-done">0</span><span style="color:#6ee7b7">h done</span> · ~<span class="stat-value" id="stat-hours-left">0</span><span style="color:#fbbf24">h remaining</span>
      </div>
      <button class="sync-btn" id="sync-btn" onclick="syncReadmeToGithub()" title="Update README.md on GitHub with current progress">
        <span id="sync-icon">⬆</span> Sync README
      </button>
    </div>
  </div>

  <div class="sidebar" id="sidebar"></div>

  <div class="main-canvas" id="main-canvas">
    <div class="canvas-controls">
      <button class="canvas-btn active" onclick="setView('dependency', event)">Dependency Map</button>
      <button class="canvas-btn" onclick="setView('timeline', event)">Timeline</button>
      <button class="canvas-btn" onclick="setView('calendar', event)">Calendar</button>
    </div>
    <div class="canvas-legend" id="canvas-legend">
      <div class="legend-item"><div class="legend-dot" style="background:var(--complete)"></div> Complete</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--in-progress)"></div> In Progress</div>
      <div class="legend-item"><div class="legend-dot" style="background:var(--not-started)"></div> Not Started</div>
      <div class="legend-item" style="color:var(--text-dim)">— prerequisite</div>
      <div class="legend-item" style="color:var(--text-dim)">┄ cross-phase</div>
    </div>
    <svg class="graph" id="graph-svg"></svg>
    <div class="mobile-view" id="mobile-dependency" style="display:none"></div>
    <div class="mobile-view" id="mobile-timeline" style="display:none"></div>
    <div id="calendar-view" style="display:none;position:absolute;inset:0;overflow-y:auto;background:var(--bg)"></div>
  </div>

  <div class="detail-backdrop" id="detail-backdrop" onclick="closeMobileDetail()"></div>

  <div class="detail-panel" id="detail-panel">
    <button class="mobile-close-btn" onclick="closeMobileDetail()">✕ Close</button>
    <div class="detail-empty" id="detail-empty">
      <div class="empty-icon">◇</div>
      <p>Click any lesson node to view details, concept checks, failure modes, and prerequisites.</p>
    </div>
    <div id="detail-content" style="display:none"></div>
  </div>
</div>

<script>
// ═══════════════════════════════════════════════
// DATA
// ═══════════════════════════════════════════════

const PHASES = [
  { id: 'p0', name: 'Setup', color: '#94a3b8', hours: '4–6h' },
  { id: 'p1', name: 'Linear Algebra', color: '#6ee7b7', hours: '35–50h' },
  { id: 'p2', name: 'Calculus & Diff Eq', color: '#818cf8', hours: '55–80h' },
  { id: 'p3', name: 'Probability & Statistics', color: '#f9a8d4', hours: '45–65h' },
  { id: 'p4', name: 'Neural Networks & Interp', color: '#fbbf24', hours: '45–65h' },
  { id: 'p5', name: 'Extended Math', color: '#e879f9', hours: '50–70h' },
  { id: 'p6', name: 'Alignment Theory', color: '#c084fc', hours: '20–30h' },
  { id: 'p7', name: 'Research', color: '#fb923c', hours: '∞' },
];

const LESSONS = [
  // ─── Phase 0: Setup ───
  {
    id: 0, phase: 'p0', title: 'Python and NumPy for Machine Learning',
    status: 'not-started', hours: '2–3h', label: '0',
    prereqs: [],
    crossPhaseLinks: [],
    conceptChecks: ['Create and manipulate arrays', 'Broadcasting rules', 'Vectorized operations'],
    failureModes: ['Writing Python loops instead of vectorized NumPy'],
    mvl: [{ type: 'Do', text: 'Matrix multiply two random matrices using np.dot, @, np.matmul. Verify all three give the same result.' }],
    projects: [],
  },
  {
    id: 1, phase: 'p0', title: 'PyTorch Fundamentals',
    status: 'not-started', hours: '2–3h', label: '1',
    prereqs: [0],
    crossPhaseLinks: [],
    conceptChecks: ['Tensors vs arrays', 'Autograd basics', 'GPU operations'],
    failureModes: ['Not understanding computational graph construction'],
    mvl: [{ type: 'Do', text: 'Build a simple linear regression in PyTorch with autograd.' }],
    projects: [],
  },
  // ─── Phase 1: Linear Algebra ───
  {
    id: 2, phase: 'p1', title: 'Vectors — What Even Are They?',
    status: 'not-started', hours: '3–4h', label: '2',
    prereqs: [1], crossPhaseLinks: [],
    conceptChecks: ['Geometric vs algebraic vectors', 'Addition and scalar multiplication', 'Component representation'],
    failureModes: ['Thinking vectors are just lists of numbers without geometric meaning'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Essence of Linear Algebra Ch.1' }],
    projects: [],
  },
  {
    id: 3, phase: 'p1', title: 'Linear Combinations, Span, and Basis',
    status: 'not-started', hours: '3–4h', label: '3',
    prereqs: [2], crossPhaseLinks: [],
    conceptChecks: ['Span as reachable space', 'Linear independence', 'Basis as coordinate system'],
    failureModes: ['Confusing "basis" with "standard basis"'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Essence of LA Ch.2' }],
    projects: [],
  },
  {
    id: 4, phase: 'p1', title: 'Linear Transformations — Matrices as Functions',
    status: 'not-started', hours: '3–5h', label: '4',
    prereqs: [3], crossPhaseLinks: [],
    conceptChecks: ['Matrices encode transformations', 'Linearity preservation', 'Column picture'],
    failureModes: ['Seeing matrix-vector multiply as just arithmetic, not transformation'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Essence of LA Ch.3' }],
    projects: [],
  },
  {
    id: 5, phase: 'p1', title: 'Matrix Operations — Composition and Inversion',
    status: 'not-started', hours: '3–4h', label: '5',
    prereqs: [4], crossPhaseLinks: [],
    conceptChecks: ['Multiplication as composition', 'Inverse as undo', 'Non-commutativity'],
    failureModes: ['Assuming AB = BA'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Essence of LA Ch.4' }],
    projects: [],
  },
  {
    id: 6, phase: 'p1', title: 'Rank, Null Space, and the Fundamental Theorem',
    status: 'not-started', hours: '3–5h', label: '6',
    prereqs: [5], crossPhaseLinks: [],
    conceptChecks: ['Rank as dimension of output', 'Null space as lost information', 'Rank-nullity theorem'],
    failureModes: ['Not connecting rank to information loss in neural networks'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Essence of LA (inverse, rank, null space)' }],
    projects: [],
  },
  {
    id: 7, phase: 'p1', title: 'The Determinant — Volume, Orientation, and Invertibility',
    status: 'not-started', hours: '2–4h', label: '7',
    prereqs: [5], crossPhaseLinks: [],
    conceptChecks: ['Det as volume scaling', 'Zero det = information loss', 'Sign = orientation'],
    failureModes: ['Computing determinants without geometric understanding'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Essence of LA Ch.6' }],
    projects: [],
  },
  {
    id: 8, phase: 'p1', title: 'Eigenvalues and Eigenvectors',
    status: 'not-started', hours: '4–5h', label: '8',
    prereqs: [7, 6], crossPhaseLinks: [],
    conceptChecks: ['Eigen = directions that only scale', 'Characteristic polynomial', 'Diagonalization'],
    failureModes: ['Missing the connection between eigenvalues and transformation behavior'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Essence of LA Ch.14' }],
    projects: [],
  },
  {
    id: 9, phase: 'p1', title: 'Singular Value Decomposition',
    status: 'not-started', hours: '4–5h', label: '9',
    prereqs: [8], crossPhaseLinks: [],
    conceptChecks: ['SVD = rotate, scale, rotate', 'Relationship to eigendecomposition', 'Low-rank approximation'],
    failureModes: ['Not seeing SVD as the universal matrix factorization'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown & Steve Brunton SVD videos' }],
    projects: [],
  },
  {
    id: 10, phase: 'p1', title: 'Dot Products, Projections, and Orthogonality',
    status: 'not-started', hours: '3–4h', label: '10',
    prereqs: [9], crossPhaseLinks: [],
    conceptChecks: ['Dot product as projection', 'Orthogonal = independent', 'Gram-Schmidt'],
    failureModes: ['Treating dot product as just a formula without geometric meaning'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Dot products and duality' }],
    projects: [],
  },
  {
    id: 11, phase: 'p1', title: 'Change of Basis and Norms',
    status: 'not-started', hours: '3–4h', label: '11',
    prereqs: [10], crossPhaseLinks: [],
    conceptChecks: ['Change of basis = rewriting in new coordinates', 'L1, L2, Linf norms', 'Norm choice affects regularization'],
    failureModes: ['Not connecting norms to regularization penalties'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Change of basis' }],
    projects: [],
  },
  {
    id: 12, phase: 'p1', title: 'Linear Algebra Capstone',
    status: 'not-started', hours: '3–5h', label: '12',
    prereqs: [11], crossPhaseLinks: [],
    conceptChecks: ['Integrate all concepts', 'Apply to ML scenario', 'Identify what tool for what problem'],
    failureModes: ['Compartmentalized knowledge that doesn\'t connect across topics'],
    mvl: [{ type: 'Do', text: 'Full integration exercise connecting vectors through SVD to ML applications' }],
    projects: [],
  },
  // ─── Phase 2: Calculus, Multivariable, Diff Eq ───
  {
    id: 13, phase: 'p2', title: 'Calculus Fundamentals',
    status: 'not-started', hours: '3–4h', label: '13',
    prereqs: [12], crossPhaseLinks: [],
    conceptChecks: ['Limits and continuity', 'Derivative as rate of change', 'Fundamental theorem of calculus'],
    failureModes: ['Rusty mechanics blocking conceptual understanding'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Essence of Calculus series' }],
    projects: [],
  },
  {
    id: 14, phase: 'p2', title: 'Matrix Calculus',
    status: 'not-started', hours: '3–5h', label: '14',
    prereqs: [13], crossPhaseLinks: [],
    conceptChecks: ['Scalar-by-vector derivatives', 'Jacobian matrix', 'Vector chain rule'],
    failureModes: ['Getting lost in notation (numerator vs denominator layout)'],
    mvl: [{ type: 'Read', text: 'MML Chapter 5' }],
    projects: [],
  },
  {
    id: 15, phase: 'p2', title: 'Partial Derivatives and Gradients',
    status: 'not-started', hours: '3–4h', label: '15',
    prereqs: [14], crossPhaseLinks: [],
    conceptChecks: ['Gradient as direction of steepest ascent', 'Gradient is perpendicular to level curves', 'Directional derivatives'],
    failureModes: ['Not connecting gradient to loss surface geometry'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Gradient' }],
    projects: [],
  },
  {
    id: 16, phase: 'p2', title: 'The Chain Rule = Backpropagation',
    status: 'not-started', hours: '3–5h', label: '16',
    prereqs: [15], crossPhaseLinks: [],
    conceptChecks: ['Chain rule composes local derivatives', 'Computation graphs', 'Forward vs backward mode'],
    failureModes: ['Treating backprop as a separate algorithm rather than the chain rule applied to a graph'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Backpropagation calculus' }],
    projects: [],
  },
  {
    id: 17, phase: 'p2', title: 'Optimization and Gradient Descent',
    status: 'not-started', hours: '3–4h', label: '17',
    prereqs: [16], crossPhaseLinks: [8],
    conceptChecks: ['Learning rate selection', 'Convexity', 'SGD, momentum, Adam'],
    failureModes: ['Memorizing optimizer formulas without understanding the geometry'],
    mvl: [{ type: 'Do', text: 'Implement gradient descent from scratch for a 2D loss function' }],
    projects: [],
  },
  {
    id: 18, phase: 'p2', title: 'Constrained Optimization and Lagrange Multipliers',
    status: 'not-started', hours: '3–4h', label: '18',
    prereqs: [17], crossPhaseLinks: [],
    conceptChecks: ['Lagrange multipliers', 'KKT conditions', 'Constrained ↔ regularized duality'],
    failureModes: ['Not seeing regularization as constraint in disguise'],
    mvl: [{ type: 'Do', text: 'Derive ridge regression as constrained optimization and show equivalence to penalized form' }],
    projects: [],
  },
  {
    id: 19, phase: 'p2', title: 'Loss Landscapes and Local Minima',
    status: 'not-started', hours: '3–4h', label: '19',
    prereqs: [18], crossPhaseLinks: [8],
    conceptChecks: ['Hessian matrix', 'Saddle points vs local minima', 'Condition number of Hessian'],
    failureModes: ['Thinking neural network loss landscapes are full of bad local minima (they mostly have saddle points)'],
    mvl: [{ type: 'Do', text: 'Visualize loss landscape of a small network. Compute Hessian eigenvalues at critical points.' }],
    projects: [],
  },
  {
    id: 20, phase: 'p2', title: 'Multiple Integration and Change of Variables',
    status: 'not-started', hours: '3–5h', label: '20',
    prereqs: [19], crossPhaseLinks: [7],
    conceptChecks: ['Double/triple integrals', 'Jacobian determinant in substitution', 'Gaussian integral', 'Monte Carlo integration'],
    failureModes: ['Not connecting Jacobian to the determinant from Lesson 7'],
    mvl: [{ type: 'Do', text: 'Derive PDF of a transformed random variable using change of variables' }],
    projects: [],
  },
  {
    id: 21, phase: 'p2', title: 'Taylor Expansions and Implicit Function Theorem',
    status: 'not-started', hours: '3–5h', label: '21',
    prereqs: [20], crossPhaseLinks: [8],
    conceptChecks: ['Multivariate Taylor expansion', 'Hessian IS second-order term', 'IFT: when can you solve implicitly', 'Big-O notation'],
    failureModes: ['Not seeing Taylor expansion as the foundation of ALL local analysis in optimization'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Taylor series' }],
    projects: [],
  },
  {
    id: 22, phase: 'p2', title: 'Introduction to ODEs',
    status: 'not-started', hours: '3–4h', label: '22',
    prereqs: [21], crossPhaseLinks: [],
    conceptChecks: ['ODEs as vector fields', 'Euler\'s method', 'Euler\'s method = gradient descent'],
    failureModes: ['Missing the deep connection: training IS solving an ODE'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Differential equations, studying the unsolvable' }],
    projects: [],
  },
  {
    id: 23, phase: 'p2', title: 'Linear Systems and Phase Portraits',
    status: 'not-started', hours: '4–5h', label: '23',
    prereqs: [22, 8], crossPhaseLinks: [],
    conceptChecks: ['Eigenvalue classification of fixed points', 'Phase portraits', 'Stability from eigenvalues'],
    failureModes: ['Not connecting eigenvalue sign/magnitude to training dynamics behavior'],
    mvl: [{ type: 'Read', text: 'Strogatz Ch.5–6' }],
    projects: [],
  },
  {
    id: 24, phase: 'p2', title: 'Gradient Flow and Training Dynamics',
    status: 'not-started', hours: '4–5h', label: '24',
    prereqs: [23], crossPhaseLinks: [17],
    conceptChecks: ['dW/dt = -∇L as continuous gradient descent', 'Lyapunov proof loss decreases', 'Learning rate stability η < 2/λ_max'],
    failureModes: ['Treating gradient flow as abstract math disconnected from actual training'],
    mvl: [{ type: 'Do', text: 'Compare discrete gradient descent with continuous gradient flow on a test problem' }],
    projects: [],
  },
  {
    id: 25, phase: 'p2', title: 'Stability, Lyapunov Functions, Phase Transitions',
    status: 'not-started', hours: '4–5h', label: '25',
    prereqs: [24], crossPhaseLinks: [],
    conceptChecks: ['Bifurcation theory', 'Grokking as phase transition', 'Safety certificates via Lyapunov functions'],
    failureModes: ['Not seeing how stability theory gives formal safety guarantees'],
    mvl: [{ type: 'Read', text: 'Strogatz Ch.3 (bifurcations)' }],
    projects: [],
  },
  {
    id: 26, phase: 'p2', title: 'Neural ODEs and Stochastic Dynamics',
    status: 'not-started', hours: '3–5h', label: '26',
    prereqs: [25], crossPhaseLinks: [],
    conceptChecks: ['ResNets as Euler steps', 'Adjoint method', 'SDEs for SGD', 'Flat vs sharp minima'],
    failureModes: ['Missing the ResNet ↔ ODE connection'],
    mvl: [{ type: 'Read', text: 'Chen et al. "Neural ODE" paper (key sections)' }],
    projects: [],
  },
  {
    id: 27, phase: 'p2', title: 'PDEs — Diffusion, Heat, and Generative Models',
    status: 'not-started', hours: '4–5h', label: '27',
    prereqs: [26], crossPhaseLinks: [],
    conceptChecks: ['Heat equation as Gaussian blurring', 'Fokker-Planck for SGD', 'Score functions and diffusion models', 'Fourier decomposition'],
    failureModes: ['Not connecting diffusion models to the heat equation — they ARE the same math'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — But what is a PDE?' }],
    projects: [],
  },
  // ─── Phase 3: Probability & Statistics ───
  {
    id: 28, phase: 'p3', title: 'Probability Distributions and Bayes\' Theorem',
    status: 'not-started', hours: '4–5h', label: '28',
    prereqs: [27], crossPhaseLinks: [],
    conceptChecks: ['Discrete vs continuous distributions', 'Joint, marginal, conditional', 'Bayes\' theorem as update rule'],
    failureModes: ['Treating Bayes\' theorem as just a formula rather than a reasoning framework'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Bayes theorem' }],
    projects: [],
  },
  {
    id: 29, phase: 'p3', title: 'Expectation, Variance, Covariance',
    status: 'not-started', hours: '3–4h', label: '29',
    prereqs: [28], crossPhaseLinks: [9],
    conceptChecks: ['E[X] as center of mass', 'Variance as spread', 'Covariance matrix = data shape'],
    failureModes: ['Not connecting covariance matrix to PCA/SVD'],
    mvl: [{ type: 'Do', text: 'Compute covariance matrix of 2D data, show eigenvectors point along data spread' }],
    projects: [],
  },
  {
    id: 30, phase: 'p3', title: 'Maximum Likelihood Estimation',
    status: 'not-started', hours: '3–5h', label: '30',
    prereqs: [29], crossPhaseLinks: [17],
    conceptChecks: ['Likelihood function', 'Log-likelihood trick', 'MLE as optimization', 'MLE for Gaussian = least squares'],
    failureModes: ['Not seeing that ML training IS MLE'],
    mvl: [{ type: 'Do', text: 'Derive the MLE for a Gaussian. Show it gives the sample mean and variance.' }],
    projects: [],
  },
  {
    id: 31, phase: 'p3', title: 'Information Theory',
    status: 'not-started', hours: '4–5h', label: '31',
    prereqs: [30], crossPhaseLinks: [],
    conceptChecks: ['Entropy as uncertainty', 'KL divergence as distance', 'Cross-entropy loss derivation', 'Mutual information'],
    failureModes: ['Not connecting cross-entropy loss to KL divergence to MLE'],
    mvl: [{ type: 'Watch', text: 'Welch Labs or 3Blue1Brown information theory content' }],
    projects: [],
  },
  {
    id: 32, phase: 'p3', title: 'Hypothesis Testing and P-Values',
    status: 'not-started', hours: '3–4h', label: '32',
    prereqs: [31], crossPhaseLinks: [],
    conceptChecks: ['Null hypothesis', 'P-value is NOT P(hypothesis is true)', 'Type I/II errors', 'Multiple testing correction'],
    failureModes: ['Misinterpreting p-values as probability the null is true'],
    mvl: [{ type: 'Watch', text: 'StatQuest — P-values and hypothesis testing' }],
    projects: [],
  },
  {
    id: 33, phase: 'p3', title: 'Experimental Design and Statistical Fallacies',
    status: 'not-started', hours: '3–4h', label: '33',
    prereqs: [32], crossPhaseLinks: [],
    conceptChecks: ['Simpson\'s paradox', 'Confounders', 'Power analysis', 'Common fallacies in ML papers'],
    failureModes: ['Accepting ML benchmark results without checking statistical methodology'],
    mvl: [{ type: 'Read', text: 'Gelman — Common statistical errors in ML papers' }],
    projects: [],
  },
  {
    id: 34, phase: 'p3', title: 'Regression — Linear to Logistic',
    status: 'not-started', hours: '4–5h', label: '34',
    prereqs: [33, 30], crossPhaseLinks: [9],
    conceptChecks: ['Linear regression = projection', 'Logistic regression = MLE for classification', 'Regularization as prior', 'Ridge vs Lasso'],
    failureModes: ['Not connecting regression to projection (Lesson 10) and SVD (Lesson 9)'],
    mvl: [{ type: 'Do', text: 'Implement linear and logistic regression from scratch using gradient descent' }],
    projects: [],
  },
  {
    id: 35, phase: 'p3', title: 'Bayesian Reasoning & Foundations',
    status: 'not-started', hours: '5–7h', label: '35',
    prereqs: [34], crossPhaseLinks: [],
    conceptChecks: ['Frequentist vs Bayesian paradigm', 'Priors as regularization', 'Conjugate priors', 'MAP = MLE + regularization', 'Sequential updating'],
    failureModes: ['Treating Bayesian inference as just "another method" rather than a complete paradigm shift'],
    mvl: [
      { type: 'Watch', text: '3Blue1Brown — Bayes theorem, geometry of changing beliefs' },
      { type: 'Read', text: 'McElreath "Statistical Rethinking" Ch.1–4' },
    ],
    projects: [],
  },
  {
    id: 36, phase: 'p3', title: 'Bayesian Computation — MCMC, VI, HMC',
    status: 'not-started', hours: '5–7h', label: '36',
    prereqs: [35, 20], crossPhaseLinks: [],
    conceptChecks: ['MCMC convergence', 'Metropolis-Hastings', 'HMC uses gradients for sampling', 'Variational inference as optimization', 'ELBO', 'VAE connection'],
    failureModes: ['Not connecting VI to VAEs — VAE training IS variational inference'],
    mvl: [
      { type: 'Read', text: 'Betancourt — "Conceptual Introduction to HMC"' },
      { type: 'Do', text: 'Implement Metropolis-Hastings from scratch for a bimodal distribution' },
    ],
    projects: [],
  },
  {
    id: 37, phase: 'p3', title: 'Bayesian Model Comparison & Free Energy',
    status: 'not-started', hours: '5–6h', label: '37',
    prereqs: [36], crossPhaseLinks: [],
    conceptChecks: ['Marginal likelihood as Occam\'s razor', 'Bayes factors', 'BIC approximation', 'WAIC', 'Free energy = -log evidence', 'SLT preview: RLCT replaces parameter counting'],
    failureModes: ['Not seeing that BIC fails for neural networks — this is the whole point of SLT'],
    mvl: [
      { type: 'Read', text: 'McElreath "Statistical Rethinking" Ch.7' },
      { type: 'Read', text: 'Watanabe "Algebraic Geometry and SLT" Ch.1 (introduction only)' },
    ],
    projects: [],
  },
  {
    id: 38, phase: 'p3', title: 'Causal Inference',
    status: 'not-started', hours: '4–5h', label: '38',
    prereqs: [37], crossPhaseLinks: [],
    conceptChecks: ['Correlation ≠ causation formalized', 'DAGs and d-separation', 'Do-calculus', 'Counterfactuals'],
    failureModes: ['Thinking you can always determine causation from observational data'],
    mvl: [{ type: 'Read', text: 'Pearl "The Book of Why" (popular) or "Causality" Ch.1–3 (technical)' }],
    projects: [],
  },
  {
    id: 39, phase: 'p3', title: 'Applied Statistics — Adjudicating Debates',
    status: 'not-started', hours: '4–5h', label: '39',
    prereqs: [38], crossPhaseLinks: [],
    conceptChecks: ['Evaluate real statistical claims', 'Genetics and epidemiology examples', 'Publication bias', 'Effect sizes vs p-values'],
    failureModes: ['Accepting or rejecting claims based on authority rather than methodology'],
    mvl: [{ type: 'Do', text: 'Find a contested statistical claim online. Analyze the methodology. Write up your assessment.' }],
    projects: [],
  },
  // ─── Phase 4: Neural Networks & Interpretability ───
  {
    id: 40, phase: 'p4', title: 'How a Single Neuron Works',
    status: 'not-started', hours: '3–4h', label: '40',
    prereqs: [39], crossPhaseLinks: [10, 17],
    conceptChecks: ['Neuron as dot product + nonlinearity', 'Activation functions', 'Universal approximation (1 layer)'],
    failureModes: ['Not seeing the neuron as a geometric separator — it computes a dot product (Lesson 10)'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Neural networks Ch.1' }],
    projects: [],
  },
  {
    id: 41, phase: 'p4', title: 'The Forward Pass as Matrix Multiplications',
    status: 'not-started', hours: '3–5h', label: '41',
    prereqs: [40], crossPhaseLinks: [4, 6],
    conceptChecks: ['Layer = affine transformation', 'Dimension analysis', 'Information bottlenecks from rank'],
    failureModes: ['Not connecting weight matrices to linear transformations (Lesson 4)'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Neural networks Ch.2' }],
    projects: [],
  },
  {
    id: 42, phase: 'p4', title: 'Backpropagation Through the Full Network',
    status: 'not-started', hours: '4–6h', label: '42',
    prereqs: [41], crossPhaseLinks: [16],
    conceptChecks: ['Backprop IS the chain rule on a computation graph', 'Gradient flow through layers', 'Vanishing/exploding gradients'],
    failureModes: ['Treating backprop as black-box magic rather than repeated chain rule application'],
    mvl: [{ type: 'Watch', text: '3Blue1Brown — Backpropagation' }],
    projects: [],
  },
  {
    id: 43, phase: 'p4', title: 'Attention — Dot Products in Action',
    status: 'not-started', hours: '4–6h', label: '43',
    prereqs: [42], crossPhaseLinks: [10, 9],
    conceptChecks: ['QKV as learned projections', 'Attention weights as soft lookup', 'Multi-head = multiple subspaces'],
    failureModes: ['Not connecting attention weights to dot product similarity (Lesson 10)'],
    mvl: [{ type: 'Watch', text: 'Andrej Karpathy — Let\'s build GPT' }],
    projects: [],
  },
  {
    id: 44, phase: 'p4', title: 'Building a Transformer from Scratch',
    status: 'not-started', hours: '6–8h', label: '44',
    prereqs: [43], crossPhaseLinks: [],
    conceptChecks: ['Positional encoding', 'Layer norm', 'Residual stream', 'Full architecture assembly'],
    failureModes: ['Copy-pasting code without understanding each component mathematically'],
    mvl: [{ type: 'Do', text: 'Implement a complete transformer and train on character-level text generation' }],
    projects: [],
  },
  {
    id: 45, phase: 'p4', title: 'Reinforcement Learning Foundations',
    status: 'not-started', hours: '4–6h', label: '45',
    prereqs: [44], crossPhaseLinks: [30],
    conceptChecks: ['MDP formalism', 'Policy gradient theorem', 'Reward shaping', 'PPO basics'],
    failureModes: ['Not connecting policy gradient to MLE — REINFORCE is MLE weighted by reward'],
    mvl: [{ type: 'Watch', text: 'Mutual Information — Policy Gradient Methods' }],
    projects: [],
  },
  {
    id: 46, phase: 'p4', title: 'The LLM Training Pipeline',
    status: 'not-started', hours: '4–6h', label: '46',
    prereqs: [45], crossPhaseLinks: [31],
    conceptChecks: ['Pre-training → SFT → RLHF pipeline', 'KL penalty', 'Constitutional AI', 'Reward model training'],
    failureModes: ['Not seeing RLHF as a Bayesian prior over behaviors (KL penalty constrains posterior)'],
    mvl: [{ type: 'Read', text: 'Ouyang et al. "Training language models to follow instructions"' }],
    projects: [],
  },
  {
    id: 47, phase: 'p4', title: 'Interpretability — What Researchers Actually Do',
    status: 'not-started', hours: '5–7h', label: '47',
    prereqs: [46], crossPhaseLinks: [],
    conceptChecks: ['Probing', 'Activation patching', 'Logit lens', 'Sparse autoencoders for feature extraction'],
    failureModes: ['Thinking interpretability means "visualize attention weights" — it\'s much deeper'],
    mvl: [
      { type: 'Watch', text: 'Neel Nanda — Mechanistic Interpretability tutorial' },
      { type: 'Read', text: 'Chris Olah — "Zoom In: An Introduction to Circuits"' },
    ],
    projects: [],
  },
  {
    id: 48, phase: 'p4', title: 'Interpretability — Circuits and Features',
    status: 'not-started', hours: '5–7h', label: '48',
    prereqs: [47], crossPhaseLinks: [3, 10],
    conceptChecks: ['Features as directions in activation space', 'Circuits as computational subgraphs', 'Superposition and polysemanticity', 'SAE dictionary learning'],
    failureModes: ['Not connecting superposition to linear algebra — it\'s about fitting more features than dimensions (Lesson 3)'],
    mvl: [
      { type: 'Read', text: 'Anthropic — "Toy Models of Superposition"' },
      { type: 'Do', text: 'Use TransformerLens to find a circuit in a small model' },
    ],
    projects: [],
  },
  {
    id: 49, phase: 'p4', title: 'Interpretability — Scaling Laws and Emergence',
    status: 'not-started', hours: '4–6h', label: '49',
    prereqs: [48], crossPhaseLinks: [],
    conceptChecks: ['Power law scaling', 'Chinchilla laws', 'Emergent capabilities', 'Phase transitions in training'],
    failureModes: ['Treating scaling laws as purely empirical without connecting to theoretical frameworks'],
    mvl: [
      { type: 'Read', text: 'Kaplan et al. "Scaling Laws for Neural Language Models"' },
    ],
    projects: [],
  },
  {
    id: 50, phase: 'p4', title: 'Interpretability — Singular Learning Theory',
    status: 'not-started', hours: '5–7h', label: '50',
    prereqs: [49, 37], crossPhaseLinks: [],
    conceptChecks: ['RLCT as effective dimension', 'Why BIC fails for NNs', 'Local Learning Coefficient', 'Phase transitions as bifurcations'],
    failureModes: ['Treating SLT as inaccessible math — the core idea (singular models have lower effective dimension) is intuitive'],
    mvl: [
      { type: 'Watch', text: 'Jesse Hoogland — SLT lectures' },
      { type: 'Read', text: 'Watanabe "Algebraic Geometry and SLT" — introduction and key theorems' },
    ],
    projects: [],
  },
  // ─── Phase 5: Extended Mathematical Foundations ───
  // Computability & Complexity
  {
    id: 51, phase: 'p5', title: 'Turing Machines and the Halting Problem',
    status: 'not-started', hours: '3–5h', label: '51',
    prereqs: [50], crossPhaseLinks: [],
    conceptChecks: ['Church-Turing thesis', 'Halting problem undecidability', 'Rice\'s theorem', 'Implications for alignment verification'],
    failureModes: ['Thinking undecidability means "nobody has solved it yet" rather than "provably impossible in general"'],
    mvl: [{ type: 'Read', text: 'Sipser Ch.3–5' }],
    projects: [],
  },
  {
    id: 52, phase: 'p5', title: 'Computational Complexity — P, NP, Feasibility',
    status: 'not-started', hours: '4–5h', label: '52',
    prereqs: [51], crossPhaseLinks: [],
    conceptChecks: ['P vs NP', 'NP-completeness', 'SAT and Cook-Levin', 'NP-hardness in ML'],
    failureModes: ['Thinking NP-hard means "impossible" — it means worst-case exponential, but average cases may be tractable'],
    mvl: [{ type: 'Read', text: 'Sipser Ch.7–8' }],
    projects: [],
  },
  {
    id: 53, phase: 'p5', title: 'Kolmogorov Complexity and Solomonoff Induction',
    status: 'not-started', hours: '3–5h', label: '53',
    prereqs: [52], crossPhaseLinks: [37],
    conceptChecks: ['K(x) as true complexity', 'Incomputability of K', 'Solomonoff prior = Occam\'s razor', 'AIXI — optimal but uncomputable and misaligned'],
    failureModes: ['Not connecting compression ↔ generalization ↔ learning'],
    mvl: [{ type: 'Read', text: 'Li & Vitanyi Ch.1–2' }],
    projects: [],
  },
  // Abstract Algebra
  {
    id: 54, phase: 'p5', title: 'Groups — Symmetry as Mathematics',
    status: 'not-started', hours: '4–5h', label: '54',
    prereqs: [53], crossPhaseLinks: [],
    conceptChecks: ['Group axioms', 'Subgroups and Lagrange\'s theorem', 'Homomorphisms and isomorphisms', 'S_n (symmetric group)'],
    failureModes: ['Treating groups as abstract nonsense — they ARE the symmetries of neural networks'],
    mvl: [{ type: 'Read', text: 'Nathan Carter "Visual Group Theory" Ch.1–6' }],
    projects: [],
  },
  {
    id: 55, phase: 'p5', title: 'Rings, Fields, and Algebraic Structures',
    status: 'not-started', hours: '4–5h', label: '55',
    prereqs: [54], crossPhaseLinks: [],
    conceptChecks: ['Ring axioms', 'Polynomial rings', 'Ideals and quotient rings', 'Fields and the Fundamental Theorem of Algebra'],
    failureModes: ['Not connecting polynomial rings to varieties — solutions of polynomials ARE geometric objects'],
    mvl: [{ type: 'Read', text: 'Nathan Carter "Visual Group Theory" Ch.7–9' }],
    projects: [],
  },
  {
    id: 56, phase: 'p5', title: 'Group Actions, Representations, and NN Symmetry',
    status: 'not-started', hours: '4–6h', label: '56',
    prereqs: [55], crossPhaseLinks: [8, 50],
    conceptChecks: ['Group actions and orbits', 'Orbit-stabilizer theorem', 'Neural network permutation symmetry', 'Equivariant architectures', 'Representations as matrices'],
    failureModes: ['Not connecting the orbit-stabilizer theorem to SLT singularities'],
    mvl: [{ type: 'Do', text: 'Show that permuting hidden neurons of a network gives the same function. Compute orbits and stabilizers.' }],
    projects: [],
  },
  // Topology & Geometry
  {
    id: 57, phase: 'p5', title: 'Point-Set Topology',
    status: 'not-started', hours: '4–5h', label: '57',
    prereqs: [56], crossPhaseLinks: [],
    conceptChecks: ['Open sets and topological spaces', 'Continuity (topological)', 'Compactness guarantees optima exist', 'Connectedness of loss landscape level sets'],
    failureModes: ['Thinking topology is too abstract to be useful — compactness is why optimization works'],
    mvl: [{ type: 'Read', text: 'Munkres "Topology" Ch.2–4' }],
    projects: [],
  },
  {
    id: 58, phase: 'p5', title: 'Homotopy and Fundamental Groups',
    status: 'not-started', hours: '4–5h', label: '58',
    prereqs: [57], crossPhaseLinks: [],
    conceptChecks: ['Homotopy equivalence', 'Fundamental group π₁', 'Covering spaces', 'Morse theory for loss landscapes'],
    failureModes: ['Not seeing Morse theory as the bridge between topology and optimization'],
    mvl: [{ type: 'Read', text: 'Hatcher "Algebraic Topology" Ch.1 (free online)' }],
    projects: [],
  },
  {
    id: 59, phase: 'p5', title: 'Manifolds and Tangent Spaces',
    status: 'not-started', hours: '4–6h', label: '59',
    prereqs: [58], crossPhaseLinks: [17],
    conceptChecks: ['Smooth manifolds', 'Tangent spaces and tangent bundles', 'Riemannian metrics', 'Natural gradient', 'Manifold hypothesis for data'],
    failureModes: ['Not connecting Riemannian gradient to the natural gradient in neural network optimization'],
    mvl: [{ type: 'Read', text: 'Loring Tu "Introduction to Manifolds" Ch.1–5' }],
    projects: [],
  },
  {
    id: 60, phase: 'p5', title: 'Algebraic Geometry — Singularities for SLT',
    status: 'not-started', hours: '5–7h', label: '60',
    prereqs: [59, 55], crossPhaseLinks: [50],
    conceptChecks: ['Algebraic varieties', 'Smooth vs singular points', 'Blow-ups resolve singularities', 'RLCT computation', 'Hironaka\'s theorem guarantees resolution'],
    failureModes: ['Being intimidated — the core idea (blow up singularities until smooth) is geometric and visual'],
    mvl: [
      { type: 'Watch', text: 'Jesse Hoogland & Murfet — SLT lectures' },
      { type: 'Read', text: 'Watanabe "Algebraic Geometry and SLT" Ch.1–4' },
    ],
    projects: [],
  },
  // Formal Logic
  {
    id: 61, phase: 'p5', title: 'Propositional and Predicate Logic',
    status: 'not-started', hours: '3–5h', label: '61',
    prereqs: [60], crossPhaseLinks: [],
    conceptChecks: ['Propositional connectives', 'Quantifiers (∀, ∃)', 'Soundness vs completeness', 'Formal verification of AI properties'],
    failureModes: ['Not seeing logic as the language of formal safety specifications'],
    mvl: [{ type: 'Read', text: 'van Dalen "Logic and Structure" Ch.1–3' }],
    projects: [],
  },
  {
    id: 62, phase: 'p5', title: 'Gödel\'s Incompleteness and Löb\'s Theorem',
    status: 'not-started', hours: '4–6h', label: '62',
    prereqs: [61, 51], crossPhaseLinks: [],
    conceptChecks: ['First incompleteness theorem', 'Second incompleteness theorem', 'Löb\'s theorem constrains self-trust', 'Diagonal lemma and self-reference', 'Implications for recursive self-improvement'],
    failureModes: ['Not seeing Löb\'s theorem as directly constraining what AI systems can prove about themselves'],
    mvl: [
      { type: 'Watch', text: 'Veritasium — "Math Has a Fatal Flaw"' },
      { type: 'Read', text: 'Yudkowsky & Herreshoff — "Tiling Agents for Self-Modifying AI"' },
    ],
    projects: [],
  },
  // ─── Phase 6: Alignment Theory ───
  {
    id: 63, phase: 'p6', title: 'Game Theory Foundations',
    status: 'not-started', hours: '4–5h', label: '63',
    prereqs: [62], crossPhaseLinks: [],
    conceptChecks: ['Nash equilibrium', 'Prisoner\'s dilemma', 'Mechanism design', 'Multi-agent alignment'],
    failureModes: ['Not connecting game theory to multi-agent AI safety scenarios'],
    mvl: [{ type: 'Read', text: 'Osborne "Introduction to Game Theory" key chapters' }],
    projects: [],
  },
  {
    id: 64, phase: 'p6', title: 'Decision Theory — CDT, EDT, and FDT',
    status: 'not-started', hours: '4–6h', label: '64',
    prereqs: [63], crossPhaseLinks: [35],
    conceptChecks: ['Causal vs evidential decision theory', 'Newcomb\'s problem', 'Functional decision theory', 'Updateless decision theory'],
    failureModes: ['Treating decision theory as a solved problem — the right theory for AI agents is still open'],
    mvl: [{ type: 'Read', text: 'Yudkowsky "Functional Decision Theory" paper' }],
    projects: [],
  },
  {
    id: 65, phase: 'p6', title: 'Anthropics and Self-Locating Beliefs',
    status: 'not-started', hours: '3–5h', label: '65',
    prereqs: [64], crossPhaseLinks: [],
    conceptChecks: ['Sleeping Beauty problem', 'Self-Sampling Assumption vs Self-Indication', 'Doomsday argument', 'Anthropics for AI copies/instances'],
    failureModes: ['Dismissing anthropics as "just philosophy" — it\'s critical for AI systems that reason about copies of themselves'],
    mvl: [{ type: 'Read', text: 'Bostrom "Anthropic Bias"' }],
    projects: [],
  },
  {
    id: 66, phase: 'p6', title: 'The Alignment Problem — Technical Foundations',
    status: 'not-started', hours: '5–7h', label: '66',
    prereqs: [65], crossPhaseLinks: [46, 50],
    conceptChecks: ['Outer vs inner alignment', 'Mesa-optimization', 'Reward hacking', 'Deceptive alignment', 'Corrigibility'],
    failureModes: ['Thinking alignment is "just make the reward function right" — the problem is much deeper'],
    mvl: [
      { type: 'Read', text: 'Hubinger et al. "Risks from Learned Optimization"' },
      { type: 'Read', text: 'Ngo et al. "The Alignment Problem from a Deep Learning Perspective"' },
    ],
    projects: [],
  },
  {
    id: 67, phase: 'p6', title: 'Open Problems and Research Frontiers',
    status: 'not-started', hours: '4–6h', label: '67',
    prereqs: [66], crossPhaseLinks: [],
    conceptChecks: ['Current alignment research landscape', 'Scalable oversight', 'Interpretability-based safety', 'Formal verification approaches', 'Your research direction'],
    failureModes: ['Analysis paralysis — at this point, start doing research, not just reading about it'],
    mvl: [
      { type: 'Read', text: 'Neel Nanda — "200 Concrete Open Problems in Mechanistic Interpretability"' },
      { type: 'Do', text: 'Pick one open problem. Write a 1-page plan for how you\'d approach it.' },
    ],
    projects: [],
  },
];

// Review checkpoints
const CHECKPOINTS = [
  {
    id: 'cp1', afterLesson: 12, phase: 'p1', title: 'Phase 1 Review: LA → ML Bridge',
    exercises: [
      '<strong>Matrix decomposition relay:</strong> Take a 4×4 matrix. Compute rank, determinant, eigenvalues, SVD. For each, state one ML application.',
      '<strong>Attention from scratch:</strong> Using ONLY linear algebra, compute Q·Kᵀ for two 3-dimensional query and key vectors. Explain the resulting scalar geometrically.',
      '<strong>Superposition puzzle:</strong> You have 5 features to represent in 3 dimensions. Find an arrangement that minimizes maximum pairwise dot product.',
    ],
  },
  {
    id: 'cp2', afterLesson: 27, phase: 'p2', title: 'Phase 2 Review: Calculus → Training Bridge',
    exercises: [
      '<strong>Full backprop trace:</strong> For a 2-layer MLP, compute the forward pass AND backward pass by hand. Verify gradients numerically.',
      '<strong>ODE → SGD:</strong> Show that gradient descent is Euler\'s method applied to the gradient flow ODE. Derive the stability condition η < 2/λ_max.',
      '<strong>Diffusion connection:</strong> Explain how adding noise to an image relates to the heat equation. What does the reverse process (denoising) require mathematically?',
    ],
  },
  {
    id: 'cp3', afterLesson: 39, phase: 'p3', title: 'Phase 3 Review: Probability → LLM Training Bridge',
    exercises: [
      '<strong>Full training loop explained:</strong> Starting from MLE, derive why cross-entropy is the loss function for next-token prediction. Connect entropy, KL divergence, and the training objective.',
      '<strong>Bayesian unification:</strong> Show that L2 weight decay = Gaussian prior = MAP estimation. Explain what the ELBO is and how maximizing it relates to fitting a VAE.',
      '<strong>Free energy preview:</strong> Explain in words why BIC (parameter counting) fails for neural networks and what the RLCT replaces it with.',
    ],
  },
  {
    id: 'cp4', afterLesson: 50, phase: 'p4', title: 'Phase 4 Review: Everything → Transformer + Interp Bridge',
    exercises: [
      '<strong>Mathematical audit:</strong> Open your GPT code. For every matrix, state: dimensions, rank, information bottleneck.',
      '<strong>End-to-end pipeline:</strong> Trace pre-training → SFT → RLHF. For each stage, name the math concepts and which lesson covers them.',
      '<strong>SLT application:</strong> How would you use the Local Learning Coefficient to detect when a model acquires a new capability during training?',
    ],
  },
  {
    id: 'cp5', afterLesson: 62, phase: 'p5', title: 'Phase 5 Review: Math → Alignment Bridge',
    exercises: [
      '<strong>Impossibility landscape:</strong> Compare the halting problem, Rice\'s theorem, Gödel\'s incompleteness, and Löb\'s theorem. How do they collectively constrain alignment?',
      '<strong>Symmetry → Singularity:</strong> Show how permutation symmetry in a neural network creates singular points in weight space. Connect to the orbit-stabilizer theorem and RLCT.',
      '<strong>Resolution sketch:</strong> For a simple singular variety, perform a blow-up by hand and identify the exceptional divisor.',
    ],
  },
  {
    id: 'cp6', afterLesson: 67, phase: 'p6', title: 'Phase 6 Review: Full Integration',
    exercises: [
      '<strong>Alignment scenario analysis:</strong> A model shows unexpected behavior. Using game theory, decision theory, Bayesian reasoning, and interpretability — write a full analysis.',
      '<strong>Mathematical connections map:</strong> Create a concept map connecting at least 20 concepts from across all phases. Each connection must be a concrete mathematical statement.',
    ],
  },
];

const LAYOUT = {
  width: 1500,
  height: 1300,
  nodes: {
    // Phase 0 - setup (far left, top)
    0:  { x: 40,  y: 30 },
    1:  { x: 40,  y: 110 },
    // Phase 1 - linear algebra (left column)
    2:  { x: 40,  y: 210 },
    3:  { x: 40,  y: 290 },
    4:  { x: 40,  y: 370 },
    5:  { x: 150, y: 370 },
    6:  { x: 95,  y: 460 },
    7:  { x: 0,   y: 460 },
    8:  { x: 40,  y: 550 },
    9:  { x: 40,  y: 640 },
    10: { x: 160, y: 640 },
    11: { x: 100, y: 730 },
    12: { x: 40,  y: 820 },
    // Phase 2 - calculus (center-left column)
    13: { x: 260, y: 110 },
    14: { x: 260, y: 200 },
    15: { x: 260, y: 280 },
    16: { x: 260, y: 360 },
    17: { x: 260, y: 440 },
    18: { x: 260, y: 520 },
    19: { x: 260, y: 600 },
    20: { x: 260, y: 680 },
    21: { x: 260, y: 760 },
    22: { x: 260, y: 840 },
    23: { x: 260, y: 920 },
    24: { x: 260, y: 1000 },
    25: { x: 260, y: 1080 },
    26: { x: 260, y: 1160 },
    27: { x: 370, y: 1160 },
    // Phase 3 - probability & statistics (center column)
    28: { x: 500, y: 30 },
    29: { x: 500, y: 110 },
    30: { x: 500, y: 190 },
    31: { x: 500, y: 270 },
    32: { x: 500, y: 350 },
    33: { x: 500, y: 430 },
    34: { x: 500, y: 510 },
    35: { x: 500, y: 600 },
    36: { x: 500, y: 690 },
    37: { x: 500, y: 780 },
    38: { x: 500, y: 870 },
    39: { x: 500, y: 960 },
    // Phase 4 - neural networks + interp (center-right column)
    40: { x: 720, y: 30 },
    41: { x: 720, y: 120 },
    42: { x: 720, y: 210 },
    43: { x: 720, y: 300 },
    44: { x: 720, y: 390 },
    45: { x: 720, y: 480 },
    46: { x: 720, y: 570 },
    47: { x: 720, y: 680 },
    48: { x: 720, y: 770 },
    49: { x: 720, y: 860 },
    50: { x: 720, y: 950 },
    // Phase 5 - extended math (right column, split into 4 subsections)
    51: { x: 940, y: 30 },
    52: { x: 940, y: 120 },
    53: { x: 940, y: 210 },
    54: { x: 940, y: 320 },
    55: { x: 940, y: 410 },
    56: { x: 940, y: 500 },
    57: { x: 940, y: 610 },
    58: { x: 940, y: 700 },
    59: { x: 940, y: 790 },
    60: { x: 940, y: 880 },
    61: { x: 940, y: 990 },
    62: { x: 940, y: 1080 },
    // Phase 6 - alignment (far right)
    63: { x: 1160, y: 110 },
    64: { x: 1160, y: 220 },
    65: { x: 1160, y: 330 },
    66: { x: 1160, y: 440 },
    67: { x: 1160, y: 550 },
  },
};



// ═══════════════════════════════════════════════
// CALENDAR STATE
// ═══════════════════════════════════════════════

const CALENDAR_KEY = 'alignment-curriculum-calendar';
let calYear = new Date().getFullYear();
let calMonth = new Date().getMonth();
let calSelectedDate = null;
let calDragLesson = null;

function loadCalendar() {
  try { return JSON.parse(localStorage.getItem(CALENDAR_KEY)) || {}; } catch(e) { return {}; }
}
function saveCalendar(cal) { localStorage.setItem(CALENDAR_KEY, JSON.stringify(cal)); }
function dateKey(y, m, d) { return `${y}-${String(m+1).padStart(2,'0')}-${String(d).padStart(2,'0')}`; }

function getScheduledDayCounts() {
  const cal = loadCalendar();
  const counts = {};
  Object.values(cal).forEach(ids => ids.forEach(id => { counts[id] = (counts[id] || 0) + 1; }));
  return counts;
}


// ═══════════════════════════════════════════════
// RENDERING ENGINE
// ═══════════════════════════════════════════════

let currentView = 'dependency';
let selectedLesson = null;

const STATUS_KEY = 'alignment-curriculum-statuses';
const STATUS_CYCLE = ['not-started', 'in-progress', 'complete'];

function loadStatuses() {
  try {
    const saved = JSON.parse(localStorage.getItem(STATUS_KEY));
    if (saved) LESSONS.forEach(l => { if (saved[l.id] !== undefined) l.status = saved[l.id]; });
  } catch(e) {}
}

function saveStatuses() {
  const obj = {};
  LESSONS.forEach(l => obj[l.id] = l.status);
  localStorage.setItem(STATUS_KEY, JSON.stringify(obj));
}

function cycleStatus(id, ev) {
  if (ev) ev.stopPropagation();
  const lesson = LESSONS.find(l => l.id === id);
  const idx = STATUS_CYCLE.indexOf(lesson.status);
  lesson.status = STATUS_CYCLE[(idx + 1) % 3];
  saveStatuses();
  refreshAll();
  if (selectedLesson === id) selectLesson(id);
}

function updateStats() {
  const total = LESSONS.length;
  const complete = LESSONS.filter(l => l.status === 'complete').length;
  const inProgress = LESSONS.filter(l => l.status === 'in-progress').length;
  document.getElementById('stat-complete').textContent = complete;
  document.getElementById('stat-total').textContent = total;
  document.getElementById('progress-fill').style.width = `${(complete / total) * 100}%`;

  function parseHours(h) {
    const m = h.match(/(\d+)–(\d+)/);
    return m ? (parseInt(m[1]) + parseInt(m[2])) / 2 : 5;
  }
  let done = 0, remaining = 0;
  LESSONS.forEach(l => {
    const h = parseHours(l.hours);
    if (l.status === 'complete') done += h;
    else remaining += h;
  });
  document.getElementById('stat-hours-done').textContent = Math.round(done);
  document.getElementById('stat-hours-left').textContent = Math.round(remaining);
}

function refreshAll() {
  renderSidebar();
  if (currentView === 'dependency') renderGraph();
  else if (currentView === 'timeline') renderTimeline();
  else if (currentView === 'calendar') renderCalendar();
  updateStats();
}

// Helper: properly quote string IDs for onclick handlers
function fmtId(id) { return typeof id === 'string' ? "'" + id + "'" : id; }

function getPhaseColor(phaseId) {
  const p = PHASES.find(ph => ph.id === phaseId);
  return p ? p.color : '#888';
}

function getStatusColor(status) {
  if (status === 'complete') return 'var(--complete)';
  if (status === 'in-progress') return 'var(--in-progress)';
  return 'var(--not-started)';
}

// ── Sidebar ──
function renderSidebar() {
  const sidebar = document.getElementById('sidebar');
  let html = '';
  PHASES.forEach(phase => {
    const phaseLessons = LESSONS.filter(l => l.phase === phase.id);
    html += `<div class="nav-section-header" onclick="toggleSection('${phase.id}')" style="color:${phase.color}">
      <span class="chevron" id="chev-${phase.id}">▾</span> ${phase.name.toUpperCase()}
    </div>`;
    html += `<div id="section-${phase.id}">`;
    phaseLessons.forEach(lesson => {
      html += `<div class="nav-item" id="nav-item-${lesson.id}" onclick="selectLesson(${fmtId(lesson.id)})">
        <div class="status-dot" style="background:${getStatusColor(lesson.status)}" onclick="cycleStatus(${fmtId(lesson.id)}, event)" title="Click to cycle status"></div>
        <span style="font-family:'JetBrains Mono',monospace;font-size:10px;opacity:0.5;width:22px">${lesson.label || lesson.id}</span>
        ${lesson.title}
      </div>`;
    });
    // Checkpoint
    const cp = CHECKPOINTS.find(c => c.phase === phase.id);
    if (cp) {
      html += `<div class="nav-item-checkpoint" onclick="selectCheckpoint('${cp.id}')">✎ ${cp.title}</div>`;
    }
    html += `</div>`;
  });
  sidebar.innerHTML = html;
}

function toggleSection(phaseId) {
  const section = document.getElementById(`section-${phaseId}`);
  const chev = document.getElementById(`chev-${phaseId}`);
  const hidden = section.style.display === 'none';
  section.style.display = hidden ? '' : 'none';
  chev.classList.toggle('collapsed', !hidden);
}

// ── Dependency Map ──
function renderGraph() {
  const svg = document.getElementById('graph-svg');
  const rect = svg.parentElement.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  const scaleX = w / LAYOUT.width;
  const scaleY = h / LAYOUT.height;
  const scale = Math.min(scaleX, scaleY) * 0.88;
  const offsetX = (w - LAYOUT.width * scale) / 2 + 20;
  const offsetY = (h - LAYOUT.height * scale) / 2 + 10;

  function tx(x) { return x * scale + offsetX; }
  function ty(y) { return y * scale + offsetY; }

  let edgesHtml = '';
  let nodesHtml = '';

  LESSONS.forEach(lesson => {
    const to = LAYOUT.nodes[lesson.id];
    lesson.prereqs.forEach(prereqId => {
      const from = LAYOUT.nodes[prereqId];
      edgesHtml += `<line class="edge" id="edge-${prereqId}-${lesson.id}" x1="${tx(from.x)}" y1="${ty(from.y)}" x2="${tx(to.x)}" y2="${ty(to.y)}" />`;
    });
    lesson.crossPhaseLinks.forEach(linkId => {
      const from = LAYOUT.nodes[linkId];
      if (from) {
        edgesHtml += `<line class="edge edge-cross-phase" id="xedge-${linkId}-${lesson.id}" x1="${tx(from.x)}" y1="${ty(from.y)}" x2="${tx(to.x)}" y2="${ty(to.y)}" />`;
      }
    });
  });

  LESSONS.forEach(lesson => {
    const pos = LAYOUT.nodes[lesson.id];
    const color = getPhaseColor(lesson.phase);
    const r = 18;
    const statusColor = getStatusColor(lesson.status);
    const fillOpacity = lesson.status === 'complete' ? 0.25 : lesson.status === 'in-progress' ? 0.15 : 0.08;

    nodesHtml += `<g class="node-group" onclick="selectLesson(${fmtId(lesson.id)})" id="node-${lesson.id}">
      <circle class="node-circle" cx="${tx(pos.x)}" cy="${ty(pos.y)}" r="${r}" fill="${color}" fill-opacity="${fillOpacity}" stroke="${statusColor}" />
      <text class="node-number" x="${tx(pos.x)}" y="${ty(pos.y) + 4}" fill="${lesson.status === 'not-started' ? color : statusColor}">${lesson.label || lesson.id}</text>
    </g>`;
  });

  const phaseLabels = [
    { x: 70,   y: 5,   color: '#94a3b8', label: 'P0 SETUP' },
    { x: 120,  y: 210, color: '#6ee7b7', label: 'P1 LINEAR ALGEBRA' },
    { x: 340,  y: 210, color: '#818cf8', label: 'P2 CALCULUS' },
    { x: 540,  y: 90,  color: '#f9a8d4', label: 'P3 PROBABILITY' },
    { x: 540,  y: 730, color: '#f472b6', label: 'P4 STATISTICS' },
    { x: 740,  y: 90,  color: '#e879f9', label: 'P5 MATH ENRICHMENT' },
    { x: 960,  y: 90,  color: '#fbbf24', label: 'P6 NEURAL NETWORKS' },
    { x: 1160, y: 390, color: '#38bdf8', label: 'P7 INTERPRETABILITY' },
    { x: 1360, y: 90,  color: '#c084fc', label: 'P8 ALIGNMENT' },
  ];

  let labelsHtml = '';
  phaseLabels.forEach(pl => {
    labelsHtml += `<text x="${tx(pl.x)}" y="${ty(pl.y)}" fill="${pl.color}" opacity="0.3" font-family="JetBrains Mono, monospace" font-size="10" font-weight="700" letter-spacing="2" text-anchor="middle">${pl.label}</text>`;
  });

  svg.innerHTML = labelsHtml + edgesHtml + nodesHtml;
}

// ── Select Lesson ──
function selectLesson(id) {
  selectedLesson = id;
  const lesson = LESSONS.find(l => l.id === id);
  if (!lesson) return;

  // Sidebar highlight
  document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
  const navItem = document.getElementById(`nav-item-${id}`);
  if (navItem) navItem.classList.add('active');

  // Edge highlighting (only in dependency view)
  if (currentView === 'dependency') {
    document.querySelectorAll('.edge').forEach(el => el.classList.remove('highlighted'));
    lesson.prereqs.forEach(pid => {
      const edge = document.getElementById(`edge-${pid}-${id}`);
      if (edge) edge.classList.add('highlighted');
    });
    lesson.crossPhaseLinks.forEach(lid => {
      const edge = document.getElementById(`xedge-${lid}-${id}`);
      if (edge) edge.classList.add('highlighted');
    });
    LESSONS.forEach(other => {
      if (other.prereqs.includes(id)) {
        const edge = document.getElementById(`edge-${id}-${other.id}`);
        if (edge) edge.classList.add('highlighted');
      }
    });
  }

  // Build detail panel
  const phase = PHASES.find(p => p.id === lesson.phase);
  let html = '';

  html += `<div class="detail-header">
    <div class="detail-phase-tag" style="color:${phase.color}">
      <div style="background:${phase.color};width:6px;height:6px;border-radius:50%"></div>
      Phase ${phase.id.replace('p','')} · ${phase.name}
    </div>
    <div class="detail-title">Lesson ${lesson.label || lesson.id}: ${lesson.title}</div>
    <div class="detail-meta">
      <div>⏱ <strong>${lesson.hours}</strong></div>
      <div>Status: <strong style="color:${getStatusColor(lesson.status)};cursor:pointer;border-bottom:1px dashed" onclick="cycleStatus(${fmtId(lesson.id)}, event)" title="Click to change">${lesson.status.replace('-', ' ')}</strong></div>
    </div>
  </div>`;

  // Prerequisites
  html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">⬆</span> Prerequisites</div>`;
  if (lesson.prereqs.length === 0 && lesson.crossPhaseLinks.length === 0) {
    html += `<p style="font-size:13px;color:var(--text-dim)">None — entry point</p>`;
  } else {
    html += `<ul class="prereq-list">`;
    lesson.prereqs.forEach(pid => {
      const p = LESSONS.find(l => l.id === pid);
      html += `<li><span class="prereq-link" onclick="selectLesson(${fmtId(pid)})">Lesson ${p.label || pid}</span>: ${p.title} <span style="color:${getStatusColor(p.status)};font-size:11px">(${p.status.replace('-',' ')})</span></li>`;
    });
    lesson.crossPhaseLinks.forEach(lid => {
      const l = LESSONS.find(ls => ls.id === lid);
      if (l) {
        html += `<li style="opacity:0.7"><span class="prereq-link" onclick="selectLesson(${fmtId(lid)})">Lesson ${l.label || lid}</span>: ${l.title} <span style="font-size:11px;color:var(--text-dim)">(cross-phase)</span></li>`;
      }
    });
    html += `</ul>`;
  }
  html += `</div>`;

  // MVL
  html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">⚡</span> Minimum Viable Lesson</div>`;
  lesson.mvl.forEach(r => {
    html += `<div class="mvl-resource"><div class="res-type">${r.type}</div>${r.text}</div>`;
  });
  html += `</div>`;

  // Concept checks
  html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">✓</span> Concept Checks</div><ul class="concept-check-list">`;
  lesson.conceptChecks.forEach(q => { html += `<li>${q}</li>`; });
  html += `</ul></div>`;

  // Failure modes
  html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">⚠</span> Common Failure Modes</div><ul class="failure-list">`;
  lesson.failureModes.forEach(f => { html += `<li>${f}</li>`; });
  html += `</ul></div>`;

  // Projects
  if (lesson.projects.length > 0) {
    html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">🔨</span> Coding Projects</div><ul class="project-list">`;
    lesson.projects.forEach(p => {
      const label = p.label || 'Project';
      html += `<li class="project-item"><span class="project-badge ${label.toLowerCase()}">${label}</span><span>${p.text}</span></li>`;
    });
    html += `</ul></div>`;
  }

  document.getElementById('detail-empty').style.display = 'none';
  document.getElementById('detail-content').style.display = 'block';
  document.getElementById('detail-content').innerHTML = html;

  // Mobile: show as bottom sheet
  if (window.innerWidth <= 900) {
    document.getElementById('detail-panel').classList.add('mobile-open');
    document.getElementById('detail-backdrop').classList.add('visible');
    document.getElementById('detail-backdrop').classList.add('open');
  }
}

function selectCheckpoint(cpId) {
  const cp = CHECKPOINTS.find(c => c.id === cpId);
  if (!cp) return;

  let html = `<div class="detail-header">
    <div class="detail-phase-tag" style="color:${getPhaseColor(cp.phase)}">
      <div style="background:${getPhaseColor(cp.phase)};width:6px;height:6px;border-radius:50%"></div>
      Review Checkpoint
    </div>
    <div class="detail-title">${cp.title}</div>
  </div>
  <div class="detail-section"><div class="detail-section-title"><span class="icon">🔗</span> Integration Exercises</div><ul class="concept-check-list">`;
  cp.exercises.forEach(ex => { html += `<li>${ex}</li>`; });
  html += `</ul></div>`;

  document.getElementById('detail-empty').style.display = 'none';
  document.getElementById('detail-content').style.display = 'block';
  document.getElementById('detail-content').innerHTML = html;

  if (window.innerWidth <= 900) {
    document.getElementById('detail-panel').classList.add('mobile-open');
    document.getElementById('detail-backdrop').classList.add('visible');
    document.getElementById('detail-backdrop').classList.add('open');
  }
}

function closeMobileDetail() {
  document.getElementById('detail-panel').classList.remove('mobile-open');
  document.getElementById('detail-backdrop').classList.remove('visible');
  document.getElementById('detail-backdrop').classList.remove('open');
}

// ── View Switching ──
function setView(view, ev) {
  currentView = view;
  document.querySelectorAll('.canvas-btn').forEach(b => b.classList.remove('active'));
  // Find the correct button even if click target is a child node
  if (ev && ev.target) {
    const btn = ev.target.closest('.canvas-btn');
    if (btn) btn.classList.add('active');
  } else {
    // Fallback: mark the button whose text matches
    document.querySelectorAll('.canvas-btn').forEach(b => {
      if (view === 'dependency' && b.textContent.includes('Dependency')) b.classList.add('active');
      else if (view === 'timeline' && b.textContent.includes('Timeline')) b.classList.add('active');
      else if (view === 'calendar' && b.textContent.includes('Calendar')) b.classList.add('active');
    });
  }

  const svg = document.getElementById('graph-svg');
  const calView = document.getElementById('calendar-view');
  const legend = document.getElementById('canvas-legend');
  const mobileDep = document.getElementById('mobile-dependency');
  const mobileTl = document.getElementById('mobile-timeline');
  const isMobile = window.innerWidth <= 900;

  // Hide everything first
  svg.style.display = 'none';
  calView.style.display = 'none';
  legend.style.display = 'none';
  mobileDep.style.display = 'none';
  mobileTl.style.display = 'none';

  // Reset detail panel when leaving calendar view (don't leave stale day-picker content)
  if (view !== 'calendar') {
    calSelectedDate = null;
    resetDetailPanel();
  }

  if (view === 'dependency') {
    if (isMobile) {
      mobileDep.style.display = 'block';
      renderMobileDependency();
    } else {
      svg.style.display = '';
      legend.style.display = 'flex';
      renderGraph();
    }
  } else if (view === 'timeline') {
    if (isMobile) {
      mobileTl.style.display = 'block';
      renderMobileTimeline();
    } else {
      svg.style.display = '';
      renderTimeline();
    }
  } else if (view === 'calendar') {
    calView.style.display = '';
    renderCalendar();
  }
}

// Reset detail panel to empty state
function resetDetailPanel() {
  selectedLesson = null;
  document.getElementById('detail-empty').style.display = '';
  document.getElementById('detail-content').style.display = 'none';
  document.getElementById('detail-content').innerHTML = '';
  document.querySelectorAll('.nav-item').forEach(el => el.classList.remove('active'));
  closeMobileDetail();
}

// ── Pace Tracker State ──
const PACE_KEY = 'alignment-curriculum-pace';
const CURRICULUM_START = '2026-02-21'; // First lesson date

// Difficulty weights by phase (relative to Phase 1 baseline)
// Based on: 6-year math gap, strong intuition, rusty mechanics
const DIFFICULTY_WEIGHT = {
  p0: 0.8, p1: 1.0, p2: 1.3, p3: 1.3,
  p4: 1.4, p5: 1.6, p6: 1.4, p7: 1.0
};

function loadPaceData() {
  try { return JSON.parse(localStorage.getItem(PACE_KEY)) || { completions: {}, startDate: CURRICULUM_START }; }
  catch(e) { return { completions: {}, startDate: CURRICULUM_START }; }
}
function savePaceData(data) { localStorage.setItem(PACE_KEY, JSON.stringify(data)); }

function recordCompletion(lessonId) {
  const data = loadPaceData();
  if (!data.completions[lessonId]) {
    data.completions[lessonId] = new Date().toISOString();
    savePaceData(data);
  }
}

function computePace() {
  const data = loadPaceData();
  const start = new Date(data.startDate);
  const now = new Date();
  const daysSinceStart = Math.max(1, (now - start) / (1000 * 60 * 60 * 24));

  // Sum content hours completed (using avg of lo-hi range)
  let completedContentHours = 0;
  LESSONS.forEach(l => {
    if (l.status === 'complete') {
      const hrs = parseHoursGlobal(l.hours);
      completedContentHours += hrs.avg;
    }
  });

  // Your actual pace: content hours per calendar day
  const paceHoursPerDay = completedContentHours / daysSinceStart;

  // Compute weighted remaining hours
  let weightedRemainLo = 0, weightedRemainHi = 0;
  LESSONS.forEach(l => {
    if (l.status !== 'complete') {
      const hrs = parseHoursGlobal(l.hours);
      const weight = DIFFICULTY_WEIGHT[l.phase] || 1.3;
      weightedRemainLo += hrs.lo * weight;
      weightedRemainHi += hrs.hi * weight;
    }
  });

  // Estimated days remaining
  const daysRemainLo = paceHoursPerDay > 0 ? Math.round(weightedRemainLo / paceHoursPerDay) : Infinity;
  const daysRemainHi = paceHoursPerDay > 0 ? Math.round(weightedRemainHi / paceHoursPerDay) : Infinity;

  // Projected completion dates
  const projLo = new Date(now.getTime() + daysRemainLo * 24 * 60 * 60 * 1000);
  const projHi = new Date(now.getTime() + daysRemainHi * 24 * 60 * 60 * 1000);

  return {
    daysSinceStart: Math.round(daysSinceStart),
    completedContentHours: Math.round(completedContentHours),
    paceHoursPerDay: paceHoursPerDay.toFixed(1),
    weightedRemainLo: Math.round(weightedRemainLo),
    weightedRemainHi: Math.round(weightedRemainHi),
    daysRemainLo, daysRemainHi,
    projLo, projHi
  };
}

function parseHoursGlobal(h) {
  const match = String(h).match(/(\d+)–(\d+)/);
  if (match) return { lo: parseInt(match[1]), hi: parseInt(match[2]), avg: (parseInt(match[1]) + parseInt(match[2])) / 2 };
  return { lo: 5, hi: 5, avg: 5 };
}

function formatDate(d) {
  const months = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
  return `${months[d.getMonth()]} ${d.getDate()}, ${d.getFullYear()}`;
}

// ── Timeline ──
function renderTimeline() {
  const svg = document.getElementById('graph-svg');
  const rect = svg.parentElement.getBoundingClientRect();
  const w = rect.width;
  const h = rect.height;

  function parseHours(h) {
    const match = String(h).match(/(\d+)–(\d+)/);
    if (match) return { lo: parseInt(match[1]), hi: parseInt(match[2]), avg: (parseInt(match[1]) + parseInt(match[2])) / 2 };
    return { lo: 5, hi: 5, avg: 5 };
  }

  // Compute totals
  let doneLo = 0, doneHi = 0, remainLo = 0, remainHi = 0, inProgLo = 0, inProgHi = 0;
  LESSONS.forEach(l => {
    const hrs = parseHours(l.hours);
    if (l.status === 'complete') { doneLo += hrs.lo; doneHi += hrs.hi; }
    else if (l.status === 'in-progress') { inProgLo += hrs.lo; inProgHi += hrs.hi; }
    else { remainLo += hrs.lo; remainHi += hrs.hi; }
  });
  const totalRemainLo = remainLo + inProgLo;
  const totalRemainHi = remainHi + inProgHi;
  const totalLo = doneLo + inProgLo + remainLo;
  const totalHi = doneHi + inProgHi + remainHi;
  const pctDone = Math.round(((doneLo + doneHi) / 2) / ((totalLo + totalHi) / 2) * 100);

  // Dynamic pace calculation
  const pace = computePace();

  let html = '';
  const cx = w / 2;

  // ── Big summary at top with pace data ──
  if (pace.completedContentHours > 0 && pace.daysRemainLo !== Infinity) {
    html += `<text x="${cx}" y="35" fill="var(--text-bright)" font-family="JetBrains Mono, monospace" font-size="24" font-weight="700" text-anchor="middle">${pace.weightedRemainLo}–${pace.weightedRemainHi} weighted hours remaining</text>`;
    html += `<text x="${cx}" y="58" fill="var(--accent-1)" font-family="JetBrains Mono, monospace" font-size="13" text-anchor="middle">Est. completion: ${formatDate(pace.projLo)} – ${formatDate(pace.projHi)}</text>`;
    html += `<text x="${cx}" y="78" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="11" text-anchor="middle">${pace.completedContentHours}h done in ${pace.daysSinceStart} days · ${pace.paceHoursPerDay}h/day pace · ${pctDone}% complete · difficulty-adjusted</text>`;
  } else {
    html += `<text x="${cx}" y="40" fill="var(--text-bright)" font-family="JetBrains Mono, monospace" font-size="26" font-weight="700" text-anchor="middle">${totalRemainLo}–${totalRemainHi} hours remaining</text>`;
    html += `<text x="${cx}" y="68" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="12" text-anchor="middle">${doneLo}–${doneHi}h complete · ${pctDone}% of curriculum · Complete lessons to activate pace tracker</text>`;
  }

  // ── Phase breakdown ──
  const margin = { top: 105, left: 60, right: 40 };
  const phaseW = w - margin.left - margin.right;
  const rowH = 52;

  PHASES.filter(p => p.id !== 'p7').forEach((phase, i) => {
    const pLessons = LESSONS.filter(l => l.phase === phase.id);
    const complete = pLessons.filter(l => l.status === 'complete').length;
    const inProg = pLessons.filter(l => l.status === 'in-progress').length;
    const total = pLessons.length;
    let pDoneLo = 0, pDoneHi = 0, pTotalLo = 0, pTotalHi = 0;
    pLessons.forEach(l => {
      const hrs = parseHours(l.hours);
      pTotalLo += hrs.lo; pTotalHi += hrs.hi;
      if (l.status === 'complete') { pDoneLo += hrs.lo; pDoneHi += hrs.hi; }
    });
    const pRemLo = pTotalLo - pDoneLo;
    const pRemHi = pTotalHi - pDoneHi;
    const weight = DIFFICULTY_WEIGHT[phase.id] || 1.0;
    const pWeightedRemLo = Math.round(pRemLo * weight);
    const pWeightedRemHi = Math.round(pRemHi * weight);
    const pPct = total > 0 ? (complete / total) : 0;
    const pPctInProg = total > 0 ? (inProg / total) : 0;

    const y = margin.top + i * rowH;
    const barX = margin.left + 200;
    const barW = phaseW - 200 - 180;
    const barH = 16;
    const barY = y + 6;

    // Phase name with difficulty weight
    html += `<text x="${margin.left}" y="${y + 18}" fill="${phase.color}" font-family="JetBrains Mono, monospace" font-size="11" font-weight="600">${phase.name}</text>`;
    html += `<text x="${margin.left}" y="${y + 32}" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="10">${complete}/${total} lessons · ${weight}× difficulty</text>`;

    // Bar background
    html += `<rect x="${barX}" y="${barY}" width="${barW}" height="${barH}" fill="var(--border)" rx="4" opacity="0.3" />`;
    if (pPct > 0) {
      html += `<rect x="${barX}" y="${barY}" width="${barW * pPct}" height="${barH}" fill="${phase.color}" rx="4" opacity="0.7" />`;
    }
    if (pPctInProg > 0) {
      html += `<rect x="${barX + barW * pPct}" y="${barY}" width="${barW * pPctInProg}" height="${barH}" fill="${phase.color}" rx="4" opacity="0.3" />`;
    }

    // Hours remaining with weighted estimate
    let hoursText;
    if (pRemLo === 0 && pRemHi === 0) {
      hoursText = '✓ done';
    } else {
      hoursText = `${pWeightedRemLo}–${pWeightedRemHi}h (adj.)`;
    }
    html += `<text x="${barX + barW + 12}" y="${y + 20}" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="10">${hoursText}</text>`;
  });

  // ── Per-lesson bars at bottom ──
  const bottomY = margin.top + PHASES.filter(p => p.id !== 'p7').length * rowH + 30;
  html += `<text x="${margin.left}" y="${bottomY}" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="10" font-weight="600">HOURS PER LESSON (colored by phase)</text>`;

  const barAreaTop = bottomY + 15;
  const barAreaH = h - barAreaTop - 40;
  const barW = Math.min(16, (phaseW) / LESSONS.length - 1);
  const gap = (phaseW - barW * LESSONS.length) / LESSONS.length;
  const maxH = Math.max(...LESSONS.map(l => parseHours(l.hours).hi));

  LESSONS.forEach((lesson, i) => {
    const x = margin.left + i * (barW + gap) + gap / 2;
    const hrs = parseHours(lesson.hours);
    const barH = (hrs.avg / maxH) * barAreaH;
    const y = barAreaTop + barAreaH - barH;
    const color = getPhaseColor(lesson.phase);
    const opacity = lesson.status === 'complete' ? 0.8 : lesson.status === 'in-progress' ? 0.5 : 0.2;

    html += `<rect x="${x}" y="${y}" width="${barW}" height="${barH}" fill="${color}" opacity="${opacity}" rx="2" cursor="pointer" onclick="selectLesson(${typeof lesson.id === 'string' ? '\'' + lesson.id + '\'' : lesson.id})" />`;
    if (barW >= 10) {
      html += `<text x="${x + barW/2}" y="${barAreaTop + barAreaH + 13}" fill="var(--text-dim)" font-family="JetBrains Mono, monospace" font-size="8" text-anchor="middle">${lesson.label || lesson.id}</text>`;
    }
  });

  svg.innerHTML = html;
}

// ── Mobile Dependency View ──
function renderMobileDependency() {
  const container = document.getElementById('mobile-dependency');

  // Track which phases are collapsed
  if (!window._mdCollapsed) window._mdCollapsed = {};

  const completedIds = new Set(LESSONS.filter(l => l.status === 'complete').map(l => l.id));

  let html = '';

  PHASES.filter(p => p.id !== 'p7').forEach(phase => {
    const pLessons = LESSONS.filter(l => l.phase === phase.id);
    const complete = pLessons.filter(l => l.status === 'complete').length;
    const total = pLessons.length;
    const isCollapsed = window._mdCollapsed[phase.id] || false;
    const allDone = complete === total;

    html += `<div class="md-phase">`;
    html += `<div class="md-phase-header${isCollapsed ? ' collapsed' : ''}" onclick="toggleMdPhase('${phase.id}')">
      <span class="md-phase-name" style="color:${phase.color}">${phase.name}</span>
      <div class="md-phase-right">
        <span class="md-phase-progress">${allDone ? '✓' : complete + '/' + total}</span>
        <span class="md-phase-chevron">▼</span>
      </div>
    </div>`;

    html += `<div class="md-phase-body${isCollapsed ? ' collapsed' : ''}">`;
    pLessons.forEach(l => {
      const statusColor = getStatusColor(l.status);
      const statusIcon = l.status === 'complete' ? '✓' : l.status === 'in-progress' ? '◐' : '';
      const statusIconColor = l.status === 'complete' ? '#000' : l.status === 'in-progress' ? '#000' : 'transparent';

      // Check prereqs
      const prereqsMet = l.prereqs.every(p => completedIds.has(p));
      const prereqLabels = l.prereqs.length > 0
        ? l.prereqs.map(p => {
            const pl = LESSONS.find(x => x.id === p);
            return (pl ? (pl.label || pl.id) : p);
          }).join(', ')
        : '';

      html += `<div class="md-lesson-card" onclick="selectLesson(${typeof l.id === 'string' ? '\'' + l.id + '\'' : l.id})">`;

      // Status toggle button
      html += `<button class="md-status-btn" style="border-color:${statusColor};background:${l.status !== 'not-started' ? statusColor : 'transparent'};color:${statusIconColor}" onclick="event.stopPropagation();cycleStatus(${typeof l.id === 'string' ? '\'' + l.id + '\'' : l.id});renderMobileDependency()">${statusIcon}</button>`;

      // Lesson info
      html += `<div class="md-lesson-info">`;
      html += `<span class="md-lesson-name"><span class="md-lesson-num" style="color:${phase.color}">${l.label || l.id}</span>${l.title}</span>`;
      html += `<div class="md-lesson-meta">`;
      html += `<span class="md-lesson-hours">${l.hours}</span>`;
      if (prereqLabels) {
        html += `<span class="md-lesson-prereqs ${prereqsMet ? 'md-prereq-met' : ''}">needs: ${prereqLabels}</span>`;
      }
      html += `</div></div>`;

      html += `<span class="md-lesson-chevron">›</span>`;
      html += `</div>`;
    });
    html += '</div></div>';
  });

  container.innerHTML = html;
}

function toggleMdPhase(phaseId) {
  if (!window._mdCollapsed) window._mdCollapsed = {};
  window._mdCollapsed[phaseId] = !window._mdCollapsed[phaseId];
  renderMobileDependency();
}

// ── Mobile Timeline ──
function renderMobileTimeline() {
  const container = document.getElementById('mobile-timeline');

  function parseHours(h) {
    const match = String(h).match(/(\d+)–(\d+)/);
    if (match) return { lo: parseInt(match[1]), hi: parseInt(match[2]), avg: (parseInt(match[1]) + parseInt(match[2])) / 2 };
    return { lo: 5, hi: 5, avg: 5 };
  }

  // Totals
  let doneLo = 0, doneHi = 0, remainLo = 0, remainHi = 0;
  LESSONS.forEach(l => {
    const hrs = parseHours(l.hours);
    if (l.status === 'complete') { doneLo += hrs.lo; doneHi += hrs.hi; }
    else { remainLo += hrs.lo; remainHi += hrs.hi; }
  });
  const totalLo = doneLo + remainLo;
  const totalHi = doneHi + remainHi;
  const pctDone = Math.round(((doneLo + doneHi) / 2) / ((totalLo + totalHi) / 2) * 100);
  const pace = computePace();

  let html = '<div class="mt-header">';
  if (pace.completedContentHours > 0 && pace.daysRemainLo !== Infinity) {
    html += `<h2>${pace.weightedRemainLo}–${pace.weightedRemainHi}h left</h2>`;
    html += `<div class="mt-subtitle">Est. ${formatDate(pace.projLo)} – ${formatDate(pace.projHi)}</div>`;
    html += `<div class="mt-meta">${pace.completedContentHours}h in ${pace.daysSinceStart}d · ${pace.paceHoursPerDay}h/day · ${pctDone}%</div>`;
  } else {
    html += `<h2>${remainLo}–${remainHi}h remaining</h2>`;
    html += `<div class="mt-meta">${doneLo}–${doneHi}h done · ${pctDone}% complete</div>`;
  }
  html += '</div>';

  PHASES.filter(p => p.id !== 'p7').forEach(phase => {
    const pLessons = LESSONS.filter(l => l.phase === phase.id);
    const complete = pLessons.filter(l => l.status === 'complete').length;
    const total = pLessons.length;
    const pPct = total > 0 ? (complete / total) : 0;
    let pRemLo = 0, pRemHi = 0;
    pLessons.forEach(l => {
      if (l.status !== 'complete') {
        const hrs = parseHours(l.hours);
        const w = DIFFICULTY_WEIGHT[phase.id] || 1.0;
        pRemLo += Math.round(hrs.lo * w);
        pRemHi += Math.round(hrs.hi * w);
      }
    });
    const hoursText = pRemLo === 0 ? '✓' : `${pRemLo}–${pRemHi}h`;

    html += `<div class="mt-phase">`;
    html += `<div class="mt-phase-header">
      <span class="mt-phase-name" style="color:${phase.color}">${phase.name}</span>
      <span class="mt-phase-stats">${complete}/${total} · ${hoursText}</span>
    </div>`;
    html += `<div class="mt-phase-bar"><div class="mt-phase-bar-fill" style="width:${pPct * 100}%;background:${phase.color};opacity:0.7"></div></div>`;
    html += `<div class="mt-phase-lessons">`;
    pLessons.forEach(l => {
      const statusColor = getStatusColor(l.status);
      html += `<div class="mt-lesson" onclick="selectLesson(${typeof l.id === 'string' ? '\'' + l.id + '\'' : l.id})">
        <span class="mt-lesson-status" style="background:${statusColor}"></span>
        <span class="mt-lesson-num" style="color:${phase.color}">${l.label || l.id}</span>
        <span class="mt-lesson-title">${l.title}</span>
        <span class="mt-lesson-hours">${l.hours}</span>
      </div>`;
    });
    html += '</div></div>';
  });

  container.innerHTML = html;
}

// ── Calendar ──
function renderCalendar() {
  const container = document.getElementById('calendar-view');
  const cal = loadCalendar();
  const today = new Date();
  const todayKey = dateKey(today.getFullYear(), today.getMonth(), today.getDate());

  const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
  const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
  const firstDow = new Date(calYear, calMonth, 1).getDay(); // 0=Sun

  let html = '';

  // Header with nav
  html += `<div class="cal-header">
    <div>
      <span class="cal-month-label">${monthNames[calMonth]} ${calYear}</span>
      <button onclick="calToday()" style="background:none;border:1px solid var(--border);color:var(--text-dim);font-family:'JetBrains Mono',monospace;font-size:10px;padding:2px 8px;border-radius:3px;cursor:pointer;margin-left:10px;vertical-align:middle">today</button>
    </div>
    <div style="display:flex;gap:4px">
      <button class="cal-nav" onclick="calPrev()">&larr;</button>
      <button class="cal-nav" onclick="calNext()">&rarr;</button>
    </div>
  </div>`;

  // Day-of-week headers
  html += `<div class="cal-grid">`;
  ['SUN','MON','TUE','WED','THU','FRI','SAT'].forEach(d => {
    html += `<div class="cal-dow">${d}</div>`;
  });

  // Empty cells before month start
  for (let i = 0; i < firstDow; i++) {
    html += `<div class="cal-day empty"></div>`;
  }

  // Day cells
  for (let d = 1; d <= daysInMonth; d++) {
    const dk = dateKey(calYear, calMonth, d);
    const isToday = dk === todayKey;
    const isSelected = dk === calSelectedDate;
    const dayLessons = (cal[dk] || []).map(id => LESSONS.find(l => l.id === id)).filter(Boolean);

    let classes = 'cal-day';
    if (isToday) classes += ' today';
    if (isSelected) classes += ' selected';

    html += `<div class="${classes}" onclick="calSelectDay('${dk}')" ondragover="event.preventDefault();this.classList.add('drag-over')" ondragleave="this.classList.remove('drag-over')" ondrop="calDrop(event,'${dk}')">`;
    html += `<div class="cal-day-num">${d}</div>`;

    dayLessons.forEach(lesson => {
      const color = getPhaseColor(lesson.phase);
      html += `<div class="cal-chip" style="background:${color}22;color:${color}" onclick="event.stopPropagation();calChipClick(${fmtId(lesson.id)},'${dk}')" title="${lesson.title} — click to view, right-click to remove" oncontextmenu="event.preventDefault();event.stopPropagation();calRemoveLesson(${fmtId(lesson.id)},'${dk}')">`;
      html += `<span class="cal-chip-num">${lesson.label || lesson.id}</span>`;
      html += `<span class="cal-chip-title">${lesson.title}</span>`;
      html += `</div>`;
    });

    html += `</div>`;
  }

  // Empty cells after month end
  const totalCells = firstDow + daysInMonth;
  const remaining = (7 - totalCells % 7) % 7;
  for (let i = 0; i < remaining; i++) {
    html += `<div class="cal-day empty"></div>`;
  }

  html += `</div>`;

  // Lesson pool - always shows all lessons
  const dayCounts = getScheduledDayCounts();
  const unplacedCount = LESSONS.filter(l => !dayCounts[l.id]).length;
  html += `<div class="cal-unscheduled">`;
  html += `<div class="cal-unscheduled-label">LESSON POOL (${unplacedCount} unplaced) — drag onto calendar or select a day and click</div>`;
  html += `<div style="display:flex;flex-wrap:wrap;gap:0">`;

  LESSONS.forEach(lesson => {
    const color = getPhaseColor(lesson.phase);
    const statusIcon = lesson.status === 'complete' ? '●' : lesson.status === 'in-progress' ? '◐' : '○';
    const days = dayCounts[lesson.id] || 0;
    const dimmed = days > 0 ? 'opacity:0.55;' : '';
    html += `<div class="cal-pool-chip" style="background:${color}15;color:${color};${dimmed}" draggable="true" ondragstart="calDragStart(event,${fmtId(lesson.id)})" onclick="calPoolClick(${fmtId(lesson.id)})" title="${lesson.title} (${lesson.hours})${days ? ' — scheduled on ' + days + ' day' + (days>1?'s':'') : ''}">`;
    html += `<span style="font-size:9px">${statusIcon}</span>`;
    html += `<span style="font-family:'JetBrains Mono',monospace;font-size:10px;font-weight:700">${lesson.label || lesson.id}</span>`;
    html += `<span style="font-family:'DM Sans',sans-serif;font-size:11px">${lesson.title}</span>`;
    if (days > 0) html += `<span style="font-family:'JetBrains Mono',monospace;font-size:9px;opacity:0.7;margin-left:2px">${days}d</span>`;
    html += `</div>`;
  });

  html += `</div></div>`;

  container.innerHTML = html;
}

function calPrev() {
  calMonth--;
  if (calMonth < 0) { calMonth = 11; calYear--; }
  renderCalendar();
}
function calNext() {
  calMonth++;
  if (calMonth > 11) { calMonth = 0; calYear++; }
  renderCalendar();
}
function calToday() {
  const t = new Date();
  calYear = t.getFullYear();
  calMonth = t.getMonth();
  renderCalendar();
}

function calSelectDay(dk) {
  calSelectedDate = (calSelectedDate === dk) ? null : dk;
  renderCalendar();

  if (calSelectedDate) {
    // Show picker in detail panel
    showDayPicker(dk);
  }
}

function showDayPicker(dk) {
  const cal = loadCalendar();
  const dayLessonIds = cal[dk] || [];
  const dayLessons = dayLessonIds.map(id => LESSONS.find(l => l.id === id)).filter(Boolean);
  const available = LESSONS.filter(l => !dayLessonIds.includes(l.id));
  const dayCounts = getScheduledDayCounts();

  const parts = dk.split('-');
  const dateStr = new Date(parseInt(parts[0]), parseInt(parts[2])-1, parseInt(parts[3]))
    .toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

  let html = `<div class="detail-header">
    <div class="detail-phase-tag" style="color:var(--accent-5)">
      <div style="background:var(--accent-5);width:6px;height:6px;border-radius:50%"></div>
      Calendar
    </div>
    <div class="detail-title">${dateStr}</div>
  </div>`;

  // Scheduled for this day
  if (dayLessons.length > 0) {
    html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">📅</span> Scheduled</div>`;
    dayLessons.forEach(lesson => {
      const color = getPhaseColor(lesson.phase);
      const otherDays = (dayCounts[lesson.id] || 1) - 1;
      const otherNote = otherDays > 0 ? ` <span style="font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--text-dim)">+${otherDays} other day${otherDays>1?'s':''}</span>` : '';
      html += `<div style="display:flex;align-items:center;gap:8px;padding:6px 0">
        <span style="font-family:'JetBrains Mono',monospace;font-size:11px;font-weight:700;color:${color}">${lesson.label || lesson.id}</span>
        <span style="font-size:12px;flex:1;cursor:pointer" onclick="selectLesson(${fmtId(lesson.id)})">${lesson.title}${otherNote}</span>
        <span style="font-family:'JetBrains Mono',monospace;font-size:10px;color:var(--text-dim)">${lesson.hours}</span>
        <button onclick="calRemoveLesson(${fmtId(lesson.id)},'${dk}')" style="background:none;border:none;color:var(--text-dim);cursor:pointer;font-size:14px;padding:2px 4px" title="Remove from this day">✕</button>
      </div>`;
    });
    html += `</div>`;
  }

  // Add lessons (not already on this day)
  if (available.length > 0) {
    html += `<div class="detail-section"><div class="detail-section-title"><span class="icon">➕</span> Add a Lesson</div>`;

    // Group by phase
    PHASES.forEach(phase => {
      const phaseLessons = available.filter(l => l.phase === phase.id);
      if (phaseLessons.length === 0) return;
      html += `<div style="font-family:'JetBrains Mono',monospace;font-size:9px;font-weight:700;color:${phase.color};letter-spacing:1px;padding:6px 0 2px;opacity:0.6">${phase.name.toUpperCase()}</div>`;
      phaseLessons.forEach(lesson => {
        const color = getPhaseColor(lesson.phase);
        const days = dayCounts[lesson.id] || 0;
        const daysBadge = days > 0 ? `<span style="font-family:'JetBrains Mono',monospace;font-size:9px;color:var(--text-dim);margin-left:4px">${days}d</span>` : '';
        html += `<div class="picker-lesson" onclick="calAddLesson(${fmtId(lesson.id)},'${dk}')">
          <span class="picker-lesson-num" style="color:${color}">${lesson.label || lesson.id}</span>
          <span>${lesson.title}${daysBadge}</span>
          <span class="picker-hours">${lesson.hours}</span>
        </div>`;
      });
    });
    html += `</div>`;
  }

  document.getElementById('detail-empty').style.display = 'none';
  document.getElementById('detail-content').style.display = 'block';
  document.getElementById('detail-content').innerHTML = html;

  if (window.innerWidth <= 900) {
    document.getElementById('detail-panel').classList.add('mobile-open');
    document.getElementById('detail-backdrop').classList.add('open');
  }
}

function calAddLesson(lessonId, dk) {
  const cal = loadCalendar();
  if (!cal[dk]) cal[dk] = [];
  if (!cal[dk].includes(lessonId)) {
    cal[dk].push(lessonId);
    saveCalendar(cal);
  }
  renderCalendar();
  showDayPicker(dk);
}

function calRemoveLesson(lessonId, dk) {
  const cal = loadCalendar();
  if (cal[dk]) {
    cal[dk] = cal[dk].filter(id => id !== lessonId);
    if (cal[dk].length === 0) delete cal[dk];
    saveCalendar(cal);
  }
  renderCalendar();
  if (calSelectedDate === dk) showDayPicker(dk);
}

function calChipClick(lessonId, dk) {
  selectLesson(lessonId);
}

function calPoolClick(lessonId) {
  if (calSelectedDate) {
    calAddLesson(lessonId, calSelectedDate);
  } else {
    selectLesson(lessonId);
  }
}

// Drag and drop
function calDragStart(ev, lessonId) {
  calDragLesson = lessonId;
  ev.dataTransfer.effectAllowed = 'move';
  ev.target.classList.add('dragging');
  setTimeout(() => { if (ev.target) ev.target.classList.remove('dragging'); }, 200);
}

function calDrop(ev, dk) {
  ev.preventDefault();
  ev.target.closest('.cal-day')?.classList.remove('drag-over');
  if (calDragLesson !== null) {
    const cal = loadCalendar();
    // Add to this day (don't remove from other days — lessons can span multiple days)
    if (!cal[dk]) cal[dk] = [];
    if (!cal[dk].includes(calDragLesson)) cal[dk].push(calDragLesson);
    saveCalendar(cal);
    calDragLesson = null;
    renderCalendar();
    if (calSelectedDate === dk) showDayPicker(dk);
  }
}


// ═══════════════════════════════════════════════
// SYNC README TO GITHUB
// ═══════════════════════════════════════════════

const GH_REPO = 'Kaxitron/research_plan';
const GH_README_PATH = 'README.md';
const GH_TOKEN_KEY = 'alignment-curriculum-gh-token';

function getGhToken() {
  let token = localStorage.getItem(GH_TOKEN_KEY);
  if (!token) {
    token = prompt('Enter your GitHub Personal Access Token (stored locally in your browser):');
    if (token) localStorage.setItem(GH_TOKEN_KEY, token.trim());
  }
  return token ? token.trim() : null;
}

// Cache the latest known SHA to avoid stale-SHA conflicts on rapid syncs
let _lastKnownSha = null;
let _syncInProgress = false;

async function syncReadmeToGithub() {
  const btn = document.getElementById('sync-btn');
  const icon = document.getElementById('sync-icon');

  // Prevent overlapping syncs
  if (_syncInProgress) return;
  _syncInProgress = true;
  btn.classList.add('syncing');
  btn.style.pointerEvents = 'none';
  icon.textContent = '⟳';

  try {
    const token = getGhToken();
    if (!token) { _syncInProgress = false; btn.classList.remove('syncing'); btn.style.pointerEvents = ''; icon.textContent = '⬆'; return; }

    // 1. Get current README — use cached SHA header to avoid redundant downloads
    const headers = { 'Authorization': `token ${token}`, 'Accept': 'application/vnd.github.v3+json' };
    const getResp = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_README_PATH}`, { headers });
    if (!getResp.ok) throw new Error(`GitHub GET failed: ${getResp.status}`);
    const fileData = await getResp.json();
    const currentSha = fileData.sha;
    let content = new TextDecoder().decode(Uint8Array.from(atob(fileData.content.replace(/\n/g, '')), c => c.charCodeAt(0)));

    // 2. Build status map from current dashboard state
    const statusMap = {};
    LESSONS.forEach(l => {
      const emoji = l.status === 'complete' ? '✅ Complete' :
                    l.status === 'in-progress' ? '🔄 In Progress' : '⬜ Not Started';
      statusMap[l.id] = emoji;
    });

    // 3. Replace status in each table row
    content = content.replace(
      /^\| (\d+) \| (.+?) \| (.+?) \|$/gm,
      (match, id, lessonCol, statusCol) => {
        const numId = parseInt(id);
        if (statusMap.hasOwnProperty(numId)) {
          return `| ${id} | ${lessonCol} | ${statusMap[numId]} |`;
        }
        return match;
      }
    );

    // 4. Push updated README — use freshest SHA (cached from last success, or just fetched)
    const shaToUse = _lastKnownSha || currentSha;
    const encodedContent = btoa(unescape(encodeURIComponent(content)));

    let putResp = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_README_PATH}`, {
      method: 'PUT',
      headers: { ...headers, 'Content-Type': 'application/json' },
      body: JSON.stringify({ message: 'Update lesson progress from dashboard', content: encodedContent, sha: shaToUse })
    });

    // 5. If 409 conflict (stale SHA), re-fetch the latest SHA and retry once
    if (putResp.status === 409) {
      console.log('SHA conflict — refetching and retrying...');
      const retryGet = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_README_PATH}`, { headers });
      if (!retryGet.ok) throw new Error(`GitHub retry GET failed: ${retryGet.status}`);
      const retryData = await retryGet.json();
      putResp = await fetch(`https://api.github.com/repos/${GH_REPO}/contents/${GH_README_PATH}`, {
        method: 'PUT',
        headers: { ...headers, 'Content-Type': 'application/json' },
        body: JSON.stringify({ message: 'Update lesson progress from dashboard', content: encodedContent, sha: retryData.sha })
      });
    }

    if (!putResp.ok) {
      const err = await putResp.json();
      throw new Error(err.message || `GitHub PUT failed: ${putResp.status}`);
    }

    // 6. Cache the new SHA from the successful response
    const putData = await putResp.json();
    if (putData.content && putData.content.sha) {
      _lastKnownSha = putData.content.sha;
    }

    // Success
    btn.classList.remove('syncing');
    btn.classList.add('success');
    icon.textContent = '✓';
    setTimeout(() => { btn.classList.remove('success'); icon.textContent = '⬆'; }, 3000);

  } catch (e) {
    console.error('Sync failed:', e);
    _lastKnownSha = null; // Clear cached SHA on error so next attempt fetches fresh
    btn.classList.remove('syncing');
    btn.classList.add('error');
    icon.textContent = '✗';
    if (e.message.includes('401') || e.message.includes('403')) {
      localStorage.removeItem(GH_TOKEN_KEY);
      alert('Authentication failed — token cleared. Try again with a valid token.');
    } else {
      alert(`Sync failed: ${e.message}`);
    }
    setTimeout(() => { btn.classList.remove('error'); icon.textContent = '⬆'; }, 3000);
  } finally {
    _syncInProgress = false;
    btn.style.pointerEvents = '';
  }
}


// ═══════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════

function refreshCurrentView() {
  const svg = document.getElementById('graph-svg');
  const calView = document.getElementById('calendar-view');
  const legend = document.getElementById('canvas-legend');
  const mobileDep = document.getElementById('mobile-dependency');
  const mobileTl = document.getElementById('mobile-timeline');
  const isMobile = window.innerWidth <= 900;

  svg.style.display = 'none';
  calView.style.display = 'none';
  legend.style.display = 'none';
  mobileDep.style.display = 'none';
  mobileTl.style.display = 'none';

  if (currentView === 'dependency') {
    if (isMobile) { mobileDep.style.display = 'block'; renderMobileDependency(); }
    else { svg.style.display = ''; legend.style.display = 'flex'; renderGraph(); }
  } else if (currentView === 'timeline') {
    if (isMobile) { mobileTl.style.display = 'block'; renderMobileTimeline(); }
    else { svg.style.display = ''; renderTimeline(); }
  } else if (currentView === 'calendar') {
    calView.style.display = '';
    renderCalendar();
  }
}

function init() {
  loadStatuses();
  renderSidebar();
  window.addEventListener('resize', () => {
    // Re-trigger current view on resize to handle mobile <-> desktop transitions
    const fakeEvent = { target: document.querySelector('.canvas-btn.active') };
    const savedView = currentView;
    // Use a small helper instead of setView to avoid event.target issues
    refreshCurrentView();
  });
}

init();
</script>
</body>
</html>

